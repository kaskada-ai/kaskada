= Tables 

Kaskada stores data in _tables_. Tables consist of multiple rows, and
each row is a value of the same type.

== Managing tables

=== Creating a Table

When creating a table, you must provide information about how each row
should be interpreted. You must describe:

* The name of a column in your data that contains the time of each row
(`time_column_name`). The time should refer to when the event occurred.
* The name of a column in your data that contains the xref:fenl:entities.adoc[entity] key of each row
(`entity_key_column_name`). The entity should identify a _thing_ in the
world that each event is associated with. Don't worry too much about
picking the "right" value here - it's easy to change the entity key in
Fenl.


Optionally:

* An subsort column associated with each row (`subsort_column_name`).
This value is used to order rows associated with the same time value.
If no subsort column is provided, Kaskada will generate one.
* A name describing the type of entity, for example "User" or "Purchase".

For more information about these fields, see:
xref:reference:expected-file-format[Expected File Format]

Here is an example of creating a table:

[source,python]
----
from kaskada import table
from kaskada.api.session import LocalBuilder

session = LocalBuilder().build()

table.create_table(
  # The table's name
  table_name = "Purchase",
  # The name of a column in your data that contains the time associated with each row
  time_column_name = "purchase_time",
  # The name of a column in your data that contains the entity key associated with each row
  entity_key_column_name = "customer_id",
)
----

This creates a table named `Purchase`. Any data loaded into this table
must have a timestamp field named `purchase_time`, `customer_id`, and a
field called `subsort_id`.

[TIP]
.Idiomatic Kaskada 
====
We like to use CamelCase to name tables because it
helps distinguish data sources from transformed values and function
names.
====

=== List Tables

The list table method returns all tables defined for your user. An
optional search string can filter the results.

Here is an example of listing tables:

[source,python]
----
from kaskada import table
from kaskada.api.session import LocalBuilder

session = LocalBuilder().build()

table.list_tables()
----

=== Get Table

You can get a table using its name:

[source,python]
----
from kaskada import table
from kaskada.api.session import LocalBuilder

session = LocalBuilder().build()

table.get_table(table = "Purchase")
----

=== Updating a Table

Tables are currently immutable. Updating a table requires deleting it
and then re-creating it with a new expression.

=== Deleting a table

You can delete a table using its name:

[source,python]
----
from kaskada import table
from kaskada.api.session import LocalBuilder

session = LocalBuilder().build()

table.delete_table(table = "Purchase")
----

[source,bash]
----
./kaskada-cli table delete -t Purchase
----

[WARNING]
====
Note that deleting a table also deletes any events uploaded to it.
====

A failed precondition error is returned if another view and/or
materialization references the table. To continue with the deletion of
the table, delete the dependent resources or supply the `force` flag to
delete the table forcefully. Forcefully deleting a table without
deleting the dependent resources may result in the dependent resources
functioning incorrectly.

[source,python]
----
from kaskada import table
from kaskada.api.session import LocalBuilder

session = LocalBuilder().build()

table.delete_table(table = "Purchase", force = True)
----

== Managing tables with the CLI and Spec files

The CLI manages Kaskada resources declaratively by managing spec files.
A spec file is a YAML file describing a set of Kaskada resources, for examples tables and views.

=== Creating, updating and deleting tables with the CLI

The CLI uses a "declarative" API - rather than modifying resources directly you describe the desired state of Kaskada, and the `kaskada-cli sync` command makes whatever changes are needed to achieve this state.
To create a table, add the table's description to your spec file and run `kaskada-cli sync apply`.
To update a table, change the table's description in your spec file and run `kaskada-cli sync apply`.
To delete a table, see xref:reference:cli.adoc#deleting-a-table[Deleting a table].

=== The format of tables in a spec file.

Tables are described in a spec file as a list of table objects under the `tables` key:

[source,yaml]
----
  # The name of the table
- tableName: GamePlay
  # A field containing the time associated with each event
  timeColumnName: event_at
  # An initial entity key associated with each event
  entityKeyColumnName: entity_key
  # An (optional) subsort column associated with each event
  subsortColumnName: offset
  # A name describing the entity key
  groupingId: User
  # Where the table's data will be stored
  # The default storage location is 'kaskada', and uses local files to store events.
  source:
    kaskada: {}

  # The name of the table
- tableName: Purchase
  # A field containing the time associated with each event
  timeColumnName: event_at
  # An initial entity key associated with each event
  entityKeyColumnName: entity_id
  # A name describing the entity key
  groupingId: User
  # Where the table's data will be stored
  # The default storage location is 'kaskada', and uses local files to store events.
  source:
    kaskada: {}
----

=== Exporting the current tables as a spec file.

You can export all the tables currently defined using the CLI.

[source,bash]
----
kaskada-cli sync export --all
----

The export result is shown below

[source,yaml]
----
tables:
- tableName: GamePlay
  timeColumnName: event_at
  entityKeyColumnName: entity_key
  subsortColumnName: offset
  groupingId: User
  source:
    kaskada: {}
- tableName: Purchase
  timeColumnName: event_at
  entityKeyColumnName: entity_id
  groupingId: User
  source:
    kaskada: {}
views:
    # ...
----

Alternately, if you know a specific table you'd like to export you can specify it explicitly.

[source,bash]
----
kaskada-cli sync export --table Purchase
----

[source,yaml]
----
tables:
- tableName: Purchase
  timeColumnName: event_at
  entityKeyColumnName: entity_id
  groupingId: User
  source:
    kaskada: {}
----

=== Updating Kaskada to reflect the contents of a spec file

To change a table with the CLI, you first modify the table in a spec file, then "apply" the spec file with the CLI.
When a spec file is applied, the CLI inspects all of the server's resources and all of the resources
defined in your spec file, then takes whatever actions are necessary to reconcile the server's state.
Applying a spec can create new tables, change a tables's mutable fields, or delete tables.

[WARNING]
.Table updates are destructive
====
Tables are currently immutable. 
When the CLI updates a table, it does so by deleting the table and re-creating it.
When this happens, all data previously loaded into the table is lost.
====

Before applying a spec file, it's a good idea to see what changes will be made. 
You can see these changes by creating an apply plan.

[source,bash]
----
kaskada-cli sync plan --file spec.yaml

# > 2:18PM INF starting plan
# > 2:18PM INF resource not found on system, will create it kind=*kaskadav1alpha.Table name=GamePlay
# > 2:18PM INF resource not found on system, will create it kind=*kaskadav1alpha.Table name=Purchase
# > 2:18PM INF Success!
----

Running this command will not make any changes to the server, but will print out the changes that will be made if you apply the given spec file.

You can apply a spec file using the CLI.

[source,bash]
----
kaskada-cli sync apply --file spec.yaml

# > 2:25PM INF starting apply
# > 2:25PM INF resource not found on system, will create it kind=*kaskadav1alpha.Table name=GamePlay
# > 2:25PM INF resource not found on system, will create it kind=*kaskadav1alpha.Table name=Purchase
# > 2:25PM INF created resource with provided spec kind=*kaskadav1alpha.Table name=GamePlay
# > 2:25PM INF created resource with provided spec kind=*kaskadav1alpha.Table name=Purchase
# > 2:25PM INF Success!
----
