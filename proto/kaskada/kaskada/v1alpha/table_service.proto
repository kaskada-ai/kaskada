syntax = "proto3";

package kaskada.kaskada.v1alpha;

import "google/api/annotations.proto";
import "google/api/field_behavior.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/wrappers.proto";
import "kaskada/kaskada/v1alpha/common.proto";
import "kaskada/kaskada/v1alpha/schema.proto";
import "kaskada/kaskada/v1alpha/sources.proto";
import "validate/validate.proto";

message Table {
  // The Table's ID.
  //
  // This value is a unique identifier for the table within a Kaskada
  // account. The ID is generated by Kaskada, and is provided as a
  // read-only field.
  string table_id = 1 [(google.api.field_behavior) = OUTPUT_ONLY];

  // The Table's Name.
  //
  // This value must be unique within an Kaskada account as it is used to
  // identify the table in Fenl queries.
  string table_name = 2 [(validate.rules).string.min_len = 1];

  // The name of the time column within the table.
  //
  // Parquet files loaded into the table must include a column with the
  // given name. The type of the column must be a 64-bit nanosecond
  // timestamp.
  //
  // Note that legacy (Parquet v1) 96-bit timestamp are NOT SUPPORTED.
  string time_column_name = 3 [(validate.rules).string.min_len = 1];

  // The name of the entity key column within the table.
  //
  // The entity key identifies an entity associated with each row.
  string entity_key_column_name = 4 [(validate.rules).string.min_len = 1];

  // The name of the subsort column within the table.
  //
  // The subsort column provides a global order across rows in a table
  // sharing the same time. Subsort columns must be globally unique per
  // row within a given time.
  //
  // It is recommended that the subsort column be populated with 64-bit
  // random integers.
  //
  // If no subsort column is provided, the system will generate the
  // subsort column as a random set of contiguous unsigned integers.
  google.protobuf.StringValue subsort_column_name = 5 [(validate.rules).string.min_len = 1];

  // Optional field to enforce joins between multiple tables
  string grouping_id = 6;

  // The creation timestamp of the table in kaskada
  google.protobuf.Timestamp create_time = 7 [(google.api.field_behavior) = OUTPUT_ONLY];

  // The update timestamp of the table in kaskada
  google.protobuf.Timestamp update_time = 8 [(google.api.field_behavior) = OUTPUT_ONLY];

  // The current version of the table
  int64 version = 9 [(google.api.field_behavior) = OUTPUT_ONLY];

  // The schema of the table.
  Schema schema = 10 [(google.api.field_behavior) = OUTPUT_ONLY];

  // The number of files in this table.
  int64 file_count = 11 [(google.api.field_behavior) = OUTPUT_ONLY];

  // The backing configuration for the table
  TableSource table_source = 12;

  message TableSource {
    oneof source {
      // By default, all tables are assumed to be Kaskada internal tables.
      KaskadaSource kaskada = 1;
      // An optional source of a Pulsar Source to read from a topic;
      PulsarSource pulsar = 2;
    }
  }
}

message ListTablesRequest {
  // Table search string.
  //
  // If provided, only tables with a name containing the given string will
  // be returned.
  string search = 1;

  // The maximum number of items to return.
  int32 page_size = 2 [(validate.rules).int32 = {
    gte: 0,
    lte: 1000
  }];

  // The next_page_token value returned from a previous List request, if
  // any. Note: if this is set, the `search` and `page_size` parameters
  // are ignored, and the values set in the original request are used
  // instead.
  string page_token = 3;
}

message ListTablesResponse {
  // A list of Tables.
  repeated Table tables = 1;

  // Token to retrieve the next page of results, or empty if there are no
  // more results in the list.
  string next_page_token = 2;

  // Information, help, or warnings related to the request
  RequestDetails request_details = 3;
}

message GetTableRequest {
  // The name of the Table to get.
  string table_name = 1 [(validate.rules).string.min_len = 1];
}

message GetTableResponse {
  // The requested Table.
  Table table = 1;

  // Information, help, or warnings related to the request
  RequestDetails request_details = 2;
}

message CreateTableRequest {
  // The Table resource to crate.
  Table table = 1 [(validate.rules).message.required = true];
}

message CreateTableResponse {
  // The Table resource that was created.
  Table table = 1;

  // Information, help, or warnings related to the request
  RequestDetails request_details = 2;
}

message DeleteTableRequest {
  // The name of the Table to delete.
  string table_name = 1 [(validate.rules).string.min_len = 1];
  // Force delete the view (defaults to false)
  bool force = 2;
}

message DeleteTableResponse {
  // The data token reflecting the state of the data after deleting the
  // table
  string data_token_id = 1;

  // Information, help, or warnings related to the request
  RequestDetails request_details = 2;
}

message LoadDataRequest {
  // The name of the Table to upload into.
  string table_name = 1 [(validate.rules).string.min_len = 1];

  oneof source_data {
    option (validate.required) = true;

    FileInput file_input = 2;
  }
}

message LoadDataResponse {
  // The data token reflecting the state of the data after load
  string data_token_id = 1;

  // Information, help, or warnings related to the request
  RequestDetails request_details = 2;
}

// A service for managing Tables.
service TableService {
  // Lists tables.
  //
  // The response includes all Tables defined for the Kaskada account.
  // If a search string is provided, only Tables matching the search
  // string are returned.
  rpc ListTables(ListTablesRequest) returns (ListTablesResponse) {
    // List method maps to HTTP GET.
    option (google.api.http) = {get: "/v1alpha/tables"};
  }

  // Gets a table.
  rpc GetTable(GetTableRequest) returns (GetTableResponse) {
    // Get maps to HTTP GET.
    option (google.api.http) = {get: "/v1alpha/tables/{table_name=*}"};
  }

  // Creates a table.
  rpc CreateTable(CreateTableRequest) returns (CreateTableResponse) {
    // Create maps to HTTP POST. URL path as the collection name.
    // HTTP request body contains the resource.
    option (google.api.http) = {
      post: "/v1alpha/tables"
      body: "table"
    };
  }

  // Deletes a table and any events loaded into it.
  rpc DeleteTable(DeleteTableRequest) returns (DeleteTableResponse) {
    option (google.api.http) = {delete: "/v1alpha/tables/{table_name=*}"};
  }

  // Loads a staged file into a table
  rpc LoadData(LoadDataRequest) returns (LoadDataResponse) {
    option (google.api.http) = {
      post: "/v1alpha/tables/load_data"
      body: "*"
    };
  }
}
