syntax = "proto3";

package kaskada.kaskada.v2alpha;

import "google/api/annotations.proto";
import "google/api/field_behavior.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";
import "kaskada/kaskada/v1alpha/common.proto";
import "kaskada/kaskada/v1alpha/destinations.proto";
import "kaskada/kaskada/v1alpha/fenl_diagnostics.proto";
import "kaskada/kaskada/v1alpha/schema.proto";
import "validate/validate.proto";

message LatestDataToken {
  string data_token_id = 1 [(google.api.field_behavior) = OUTPUT_ONLY];
}

message SpecificDataToken {
  string data_token_id = 1 [(validate.rules).string.min_len = 1];
}

message DataToken {
  oneof data_token {
    option (validate.required) = true;

    // Use the latest available data token for the query
    LatestDataToken latest_data_token = 1;

    // UUID of data token to use for query
    SpecificDataToken specific_data_token = 2;
  }
}

message QueryView {
  // The View's Name.
  //
  // This value must be unique within an Kaskada account as it is used to
  // identify the view in Fenl queries.
  string view_name = 1 [(validate.rules).string.min_len = 1];

  // The View's Fenl expression.
  string expression = 2 [(validate.rules).string.min_len = 1];
}

message AllResults {
  // Time bound (inclusive) after which results will be output.
  //
  // Results will include rows for changes (events and ticks) after this time (inclusive).
  google.protobuf.Timestamp changed_since_time = 1;
}

message FinalResults {
  // Time bound (inclusive) after which results will be output.
  //
  // Results will include a final result for any entity that would be included in the changed results.
  google.protobuf.Timestamp changed_since_time = 1;

  // Time bound (inclusive) which final results will include.
  google.protobuf.Timestamp final_result_time = 2;
}

message FinalResultsAtTime {
  // Time bound (inclusive) after which results will be output.
  //
  // Results will include a final result for any entity that would be included in the changed results.
  google.protobuf.Timestamp changed_since_time = 1;

  // Time bound (inclusive) which final results will include.
  google.protobuf.Timestamp final_result_time = 2;
}

message ResultBehavior {
  oneof result_behavior {
    option (validate.required) = true;

    // All results are returned
    AllResults all_results = 1;

    // Only the most recent event for each entity will be returned
    FinalResults final_results = 2;

    // Only the most recent event (inclusive limit) for each entity will be returned
    FinalResultsAtTime final_results_at_time = 3;
  }
}

message QueryLimits {
  // Produces a preview of the data with at least this many rows.
  int64 preview_rows = 1;
}

message QueryViews {
  // The views utilized in the query
  repeated QueryView views = 1;
}

message QueryConfig {
  // Optional. A token to run queries against. Enables repeatable queries.
  // if ommitted, the latest dataToken is used.
  DataToken data_token = 1;

  // How to slice the input data for the query
  kaskada.v1alpha.SliceRequest slice = 2;

  // Configures how the query results should be returned.
  kaskada.v1alpha.Destination destination = 3;

  // Determines how results are returned.
  ResultBehavior result_behavior = 4;

  // Configure limits on the output set.
  QueryLimits limits = 5;

  repeated string experimental_features = 6;
}

enum QueryState {
  QUERY_STATE_UNSPECIFIED = 0;
  QUERY_STATE_COMPILED = 1;
  QUERY_STATE_PREPARING = 2;
  QUERY_STATE_PREPARED = 3;
  QUERY_STATE_COMPUTING = 4;
  QUERY_STATE_SUCCESS = 5;
  QUERY_STATE_FAILURE = 6;
}

message CSVResults {
  // URIs identifying the CSV files containing the query
  // results.
  repeated string paths = 1;
}

message ParquetResults {
  // URIs identifying the Parquet files containing the query
  // results.
  repeated string paths = 1;
}

message QueryOutput {
  kaskada.v1alpha.FileResults file_results = 1;
}

message QueryResults {
  // Contains URIs to the query output when returning
  // file-based results from the query
  QueryOutput output = 1;

  // Diagnostic information about the query
  kaskada.v1alpha.FenlDiagnostics fenl_diagnostics = 2;

  // The schema of the query.  If this is empty, check
  // `fenl_diagnostics` for reasons.
  kaskada.v1alpha.Schema schema = 3;
}

message QueryMetrics {
  // Time spent preparing input
  google.protobuf.Duration time_preparing = 1;

  // Time spent computing results
  google.protobuf.Duration time_computing = 2;

  // The number of output files produced.
  int64 output_files = 3;

  // Total input rows to be processed by this query.
  int64 total_input_rows = 4;

  // Number of input rows processed by this query.
  int64 processed_input_rows = 5;

  // The number of output rows produced so far.
  int64 produced_output_rows = 6;
}

message Query {
  // The query's ID.
  //
  // This value is a unique identifier for the query within a Kaskada
  // account. The ID is generated by Kaskada, and is provided as a
  // read-only field.
  string query_id = 1 [(google.api.field_behavior) = OUTPUT_ONLY];

  // The creation timestamp of the query in kaskada
  google.protobuf.Timestamp create_time = 2 [(google.api.field_behavior) = OUTPUT_ONLY];

  // The update timestamp of the query in kaskada.  This timestamp
  // updates as progress is being made on the query
  google.protobuf.Timestamp update_time = 3 [(google.api.field_behavior) = OUTPUT_ONLY];

  // A Fenl expression to compute
  string expression = 4 [(validate.rules).string.min_len = 1];

  // The views used by the expression
  QueryViews views = 5 [(google.api.field_behavior) = OUTPUT_ONLY];

  // The configuration of the query provided at create-time
  QueryConfig config = 6 [(google.api.field_behavior) = OUTPUT_ONLY];

  // The current state of the query
  QueryState state = 7 [(google.api.field_behavior) = OUTPUT_ONLY];

  // The results of the query
  QueryResults results = 8 [(google.api.field_behavior) = OUTPUT_ONLY];

  // Metrics about the query execution
  QueryMetrics metrics = 9 [(google.api.field_behavior) = OUTPUT_ONLY];
}

message CreateQueryRequest {
  // A Fenl expression to compute.
  string expression = 1 [(validate.rules).string.min_len = 1];

  // Any views used by the expression
  QueryViews views = 2;

  // The configuration of the query
  QueryConfig config = 3;

  // Attempt to create a query, but don't save it to the database,
  // or initiate compute on it. See the `QueryResults` object in
  // the response for diagnostic and schema info.
  bool dry_run = 4;
}

message CreateQueryResponse {
  // The requested Query.
  Query query = 1;

  // Information, help, or warnings related to the request
  kaskada.v1alpha.RequestDetails request_details = 2;
}

message DeleteQueryRequest {
  // The ID of the Query to delete.
  string query_id = 1 [(validate.rules).string.min_len = 1];
}

message DeleteQueryResponse {
  // Information, help, or warnings related to the request
  kaskada.v1alpha.RequestDetails request_details = 1;
}

message GetQueryRequest {
  // The ID of the Query to get.
  string query_id = 1 [(validate.rules).string.min_len = 1];

  // If this is `true`, then file-based results will be pre-signed
  // before being returned.
  //
  // The files can be read with HTTP, and will be available for a
  // fixed amount of time (TTL).
  //
  // For example: When running the engine with S3 as the backing
  // store, and working locally, set this to true to return
  // results as HTTP URLs instead of S3 URIs.  The returned URLs
  // can be used to download the results file without additional
  // authenticaiton to S3.
  bool presign_results = 2;
}

message GetQueryResponse {
  // The requested Query.
  Query query = 1;

  // Information, help, or warnings related to the request
  kaskada.v1alpha.RequestDetails request_details = 2;
}

message ListQueriesRequest {
  // Query search string.
  //
  // If provided, only queries cointaining the given string will
  // be returned.
  string search = 1;
  // The maximum number of items to return.
  int32 page_size = 2 [(validate.rules).int32 = {
    gte: 0,
    lte: 1000
  }];

  // The next_page_token value returned from a previous List request, if
  // any. Note: if this is set, the `search` and `page_size` parameters
  // are ignored, and the values set in the original request are used
  // instead.
  string page_token = 3;
}

message ListQueriesResponse {
  // A list of queries.
  repeated Query queries = 1;
  // Token to retrieve the next page of results, or empty if there are no
  // more results in the list.
  string next_page_token = 2;
  // Information, help, or warnings related to the request
  kaskada.v1alpha.RequestDetails request_details = 3;
}

service QueryService {
  // Creates a Query for processing
  rpc CreateQuery(CreateQueryRequest) returns (CreateQueryResponse) {
    option (google.api.http) = {
      post: "/v2alpha/query"
      body: "*"
    };
  }

  // Deletes a query, stopping any processing on it.
  rpc DeleteQuery(DeleteQueryRequest) returns (DeleteQueryResponse) {
    option (google.api.http) = {delete: "/v2alpha/query/{query_id=*}"};
  }

  // Gets a Query.
  rpc GetQuery(GetQueryRequest) returns (GetQueryResponse) {
    option (google.api.http) = {get: "/v2alpha/query/{query_id=*}"};
  }

  // Lists queries.
  //
  // The response includes all Queries defined for the Kaskada account.
  // If a search string is provided, only Queries matching the search string
  // are returned.
  rpc ListQueries(ListQueriesRequest) returns (ListQueriesResponse) {
    // List method maps to HTTP GET.
    option (google.api.http) = {get: "/v2alpha/query"};
  }
}
