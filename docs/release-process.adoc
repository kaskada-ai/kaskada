:repo: https://github.com/kaskada-ai/kaskada

# Release Process

This document describes the release processed used by the Kaskada project.
It describes how the automation supporting the release is configured, as well as how to perform a release.

## Component Groups

The Kaskada project contains multiple components which are versioned and released separately.
To reduce the number of parts, components are grouped together, with the components in a group being versioned and released together.
Currently, there are two released in groups.

engine:: The engine release consists of the compute engine (sparrow), the intermediary (wren) and the protocol buffer definitions.
python:: The python release consists of the Python gRPC client and the Fenl IPython magic.

## Versioning and Compatibility

Component groups are assigned version numbers using https://semver.org/[semver].

The process is automated by <<release_drafter,Release Drafter>> as part of drafting the release notes.
If there are any PRs with the `enhancement` label, the next release is at least a minor revision.
If there are any PRs with the `breaking` or `removal` label, the next release is a major revision.
If there are no PRs with any of those labels, the next release defaults to a patch revision.

WARNING: The process for versioning relies on properly labeling PRs as `breaking` or `removal`.
This means it is possible that a breaking change (which should requiire a major revision) is misidentified as a minor revision.
In such cases, we will seek to undo the breaking changes as outlined in <<accidental_breaking_changes>>.

### Accidental Breaking Changes [[accidental_breaking_changes]]

In the event that a breaking change was accidentally released as a minor revision, we will use a process similar to the following to fix thiings.

1. Revert the breaking change and release a new minor or patch release with.
The intention is to ensure that anyone who has pinned to the major (or minor, if applicable) version isn't broken.
2. If the breaking change is deemed necessary, prepare a new *major* release containing those changes.
If the breaking change was accidental and not necessary, leave the change reverted.

## Changelogs [[release_drafter]]

Changelogs are automatically generated by https://github.com/release-drafter/release-drafter[release-drafter].

The link:../.github/workflows/release_drafter.yml[`.github/workflows/release_drafter.yml`] workflow creates draft release notes for each component group.
The draft releases may be seen by going to link:{repo}/releases[releases].
This is useful for determining the next version to release (as part of performing the release process) as well as getting a sense of the not-yet-released features.

Producing the changelog uses two sets of labels.
The "component" labels include link:{repo}/labels/sparrow[sparrow], link:{repo}/labels/wren[wren], etc. and indicate which component(s) a given PR affects.
The "kind" labels include link:{repo}/labels/enhancement[enhancement], link:{repo}/labels/bug[bug], etc. and affect  which category the PR appears in when added to the release notes.
The kind is also used to determine the minimum version for the next release -- if there is new functionality (`enhancement`) or removed functionality (`removal`) then it must be at least minor version.

NOTE: The `highlight` (tag applied to issues to highlight in the release notes), `removal`, `breaking` and `skip-changelog` labels must be manually applied to PRs.

TIP: The changelogs can be regenertaed by updating the lables on PRs and re-running the release drafter.
This will happen automatically when any PR is merged to main.
It may be manually dispatched at the link:{repo}/actions/workflows/release_drafter.yml[GitHub Actions view].

### Automatic PR Labels

Release drafter is ralso run by link:../.github/workflows/pr_labeler.yml[`.github/workflows/pr_labeler.yml`] on all pull requests to apply labels to PRs based on title and files modified.
The rules for applying these labels are in the configuration `.github/release-drafter.yml`.
Generally, component labels are inferred based on the files modified and kind labels are inferred from the PR title.

### Defined GitHub Labels

GitHub labels are defined by code in link:../.github/labels.yml[`.github/labels.yml`].
The link:../.github/workflows/sync_labels.yml[Sync labels workflow] runs when a PR updating the labels is merged to `main`.

## Performing Releases

The process of building and releasing is automated by GitHub Action workflows.
Each component group defines a `.github/workflows/release_<name>.yml` workflow.
The workflows run in response to the creation of a new release tag of the form `<name>@vX.Y.Z`.
See <<release_workflows>> for more details on what each the workflow for each component group does.

Generally, releasing a component involves:

1. Checking the link:{repo}/releases[release page] on GitHub to find the appropriate draft release and corresponding version number.
2. Merging a `release` PR that updates version information of the corresponding components.
3. Publishing the draft release, which automatically creates a tag and triggers the corresponding workflow to finish the release.
4. Watching that the release has been created successfully.

### Engine Component Group

. Check the link:{repo}/releases[release page] on GitHub to find the appropriate draft release and corresponding version number for the Engine.
. Create a PR updating version numbers for sparrow (`Cargo.toml`) and wren (`wren/.version`) to the appropriate version number from step 1. 
. Merge the PR.
. Create a new tag
.. Using GitHub 
... Go to link:{repo}/releases/new[releases/new].
... Enter the tag name (e.g. `engine@vX.Y.Z`). The values for X, Y and Z you should have gotten from the draft release. 
... Add a release title 
... Add a description for this release 
... Ensure that `Set as the latest release` check box *is selected*. 
... Click `Publish release`. 
... This should kick off the CI workflow for a release, monitor the progress of the workflow by going to link:{repo}actions/workflows/release_engine.yml[Engine Release Workflow]
... Once the workflow is complete, check that the release was created successfully by going to link:{repo}/releases[releases] and checking that the release is there.
.. Using the command line
... Check out the repo at the commit that contains your changes to the version numbers in the `Cargo.toml` and `wren/.version` files.
... Create a new tag with the appropriate version number (e.g. `git tag -a engine@vX.Y.Z -m "Engine vX.Y.Z"`). The values for X, Y and Z you should have gotten from the draft release.
... Push the tag to GitHub (e.g. `git push origin`). 
... This should kick off the CI workflow for a release, monitor the progress of the workflow by going to link:{repo}actions/workflows/release_engine.yml[Engine Release Workflow]
... Once the workflow is complete, check that the release was created successfully by going to link:{repo}/releases[releases] and checking that the release is there *and marked as `latest`*.


### Python Component Group


[IMPORTANT]
====
The Python client release relies on 

. having the `latest` release on GitHub tagged for the engine with binary files for engine and manager present in the release
.  there is not pending engine release happening at the same time. 


If you have to release new versions for both engine and python components, do them serially, first the engine and then the python component.
====

. Check the link:{repo}/releases[release page] on GitHub to find the appropriate draft release and corresponding version number for the Python Client.
. Make sure that there 
.. is one release that is marked as `latest` *and is for the latest engine release*
.. the engine release tagged as `latest` has the engine and manager binaries attached to it 
.. there is no *pending engine release happening at the same time* 
. Create a PR updating version numbers for the Python client (`clients/python/pyproject.toml`)
. Merge the PR.
. Create a new tag 
.. Using GitHub
.. Go to link:{repo}/releases/new[releases/new].
.. Enter the tag name (e.g. `python@v.X.Y.Z`). The values for X, Y and Z you should have gotten from the draft release.
.. Add a release title
.. Add a description for this release
.. Ensure that `Set as the latest release` check box *is NOT selected*.
.. Click `Publish release`.
.. This should kick off the CI workflow for a release, monitor the progress of the workflow by going to link:{repo}actions/workflows/release_python_client.yml[Python Release Workflow]
.. Once the workflow is complete, 
... check that the release was created successfully by going to link:{repo}/releases[releases] and checking that the release is there.
... check that the release is *not* marked as `latest`.
... check that https://pypi.org/project/kaskada/#description[Kaskada at PyPi] has the new version.
.. Using the command line
... Check out the repo at the commit that contains your changes to the version number in the `pyproject.toml` file.
... Create a new tag with the appropriate version number (e.g. `git tag -a python@vX.Y.Z -m "Python Client vX.Y.Z"`). The values for X, Y and Z you should have gotten from the draft release.
... Push the tag to GitHub (e.g. `git push origin`). 
... This should kick off the CI workflow for a release, monitor the progress of the workflow by going to link:{repo}actions/workflows/release_python_client.yml[Python Release Workflow]
... Once the workflow is complete, 
.... check that the release was created successfully by going to link:{repo}/releases[releases]
.... check that the release is *not* marked as `latest`.
.... check that https://pypi.org/project/kaskada/#description[Kaskada at PyPi] has the new version.


### Patch Releases

WARNING: TODO discussing tagging and branching, how to do patch releases.

## Release Workflows [[release_workflows]]

Every release workflow includes the following steps:

1. Creating a release branch based on the tag.
This provides a place for future documentation modifications.
2. Building the release artifacts.
3. Deploying release artifacts as appropriate for the component(s).
4. Publishing the release draft on GitHub.
