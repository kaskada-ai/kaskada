// Code generated by mockery v2.27.1. DO NOT EDIT.

package compute

import (
	context "context"

	client "github.com/kaskada-ai/kaskada/wren/client"

	ent "github.com/kaskada-ai/kaskada/wren/ent"

	internal "github.com/kaskada-ai/kaskada/wren/internal"

	kaskadav1alpha "github.com/kaskada-ai/kaskada/gen/proto/go/kaskada/kaskada/v1alpha"

	kaskadav2alpha "github.com/kaskada-ai/kaskada/gen/proto/go/kaskada/kaskada/v2alpha"

	mock "github.com/stretchr/testify/mock"

	uuid "github.com/google/uuid"
)

// MockComputeManager is an autogenerated mock type for the ComputeManager type
type MockComputeManager struct {
	mock.Mock
}

type MockComputeManager_Expecter struct {
	mock *mock.Mock
}

func (_m *MockComputeManager) EXPECT() *MockComputeManager_Expecter {
	return &MockComputeManager_Expecter{mock: &_m.Mock}
}

// CompileQuery provides a mock function with given fields: ctx, owner, query, requestViews, isFormula, isExperimental, sliceRequest, resultBehavior
func (_m *MockComputeManager) CompileQuery(ctx context.Context, owner *ent.Owner, query string, requestViews []*kaskadav1alpha.WithView, isFormula bool, isExperimental bool, sliceRequest *kaskadav1alpha.SliceRequest, resultBehavior kaskadav1alpha.Query_ResultBehavior) (*kaskadav1alpha.CompileResponse, error) {
	ret := _m.Called(ctx, owner, query, requestViews, isFormula, isExperimental, sliceRequest, resultBehavior)

	var r0 *kaskadav1alpha.CompileResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ent.Owner, string, []*kaskadav1alpha.WithView, bool, bool, *kaskadav1alpha.SliceRequest, kaskadav1alpha.Query_ResultBehavior) (*kaskadav1alpha.CompileResponse, error)); ok {
		return rf(ctx, owner, query, requestViews, isFormula, isExperimental, sliceRequest, resultBehavior)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ent.Owner, string, []*kaskadav1alpha.WithView, bool, bool, *kaskadav1alpha.SliceRequest, kaskadav1alpha.Query_ResultBehavior) *kaskadav1alpha.CompileResponse); ok {
		r0 = rf(ctx, owner, query, requestViews, isFormula, isExperimental, sliceRequest, resultBehavior)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kaskadav1alpha.CompileResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ent.Owner, string, []*kaskadav1alpha.WithView, bool, bool, *kaskadav1alpha.SliceRequest, kaskadav1alpha.Query_ResultBehavior) error); ok {
		r1 = rf(ctx, owner, query, requestViews, isFormula, isExperimental, sliceRequest, resultBehavior)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockComputeManager_CompileQuery_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileQuery'
type MockComputeManager_CompileQuery_Call struct {
	*mock.Call
}

// CompileQuery is a helper method to define mock.On call
//   - ctx context.Context
//   - owner *ent.Owner
//   - query string
//   - requestViews []*kaskadav1alpha.WithView
//   - isFormula bool
//   - isExperimental bool
//   - sliceRequest *kaskadav1alpha.SliceRequest
//   - resultBehavior kaskadav1alpha.Query_ResultBehavior
func (_e *MockComputeManager_Expecter) CompileQuery(ctx interface{}, owner interface{}, query interface{}, requestViews interface{}, isFormula interface{}, isExperimental interface{}, sliceRequest interface{}, resultBehavior interface{}) *MockComputeManager_CompileQuery_Call {
	return &MockComputeManager_CompileQuery_Call{Call: _e.mock.On("CompileQuery", ctx, owner, query, requestViews, isFormula, isExperimental, sliceRequest, resultBehavior)}
}

func (_c *MockComputeManager_CompileQuery_Call) Run(run func(ctx context.Context, owner *ent.Owner, query string, requestViews []*kaskadav1alpha.WithView, isFormula bool, isExperimental bool, sliceRequest *kaskadav1alpha.SliceRequest, resultBehavior kaskadav1alpha.Query_ResultBehavior)) *MockComputeManager_CompileQuery_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*ent.Owner), args[2].(string), args[3].([]*kaskadav1alpha.WithView), args[4].(bool), args[5].(bool), args[6].(*kaskadav1alpha.SliceRequest), args[7].(kaskadav1alpha.Query_ResultBehavior))
	})
	return _c
}

func (_c *MockComputeManager_CompileQuery_Call) Return(_a0 *kaskadav1alpha.CompileResponse, _a1 error) *MockComputeManager_CompileQuery_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockComputeManager_CompileQuery_Call) RunAndReturn(run func(context.Context, *ent.Owner, string, []*kaskadav1alpha.WithView, bool, bool, *kaskadav1alpha.SliceRequest, kaskadav1alpha.Query_ResultBehavior) (*kaskadav1alpha.CompileResponse, error)) *MockComputeManager_CompileQuery_Call {
	_c.Call.Return(run)
	return _c
}

// CompileQueryV2 provides a mock function with given fields: ctx, owner, expression, formulas, config
func (_m *MockComputeManager) CompileQueryV2(ctx context.Context, owner *ent.Owner, expression string, formulas []*kaskadav1alpha.Formula, config *kaskadav2alpha.QueryConfig) (*kaskadav1alpha.CompileResponse, error) {
	ret := _m.Called(ctx, owner, expression, formulas, config)

	var r0 *kaskadav1alpha.CompileResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ent.Owner, string, []*kaskadav1alpha.Formula, *kaskadav2alpha.QueryConfig) (*kaskadav1alpha.CompileResponse, error)); ok {
		return rf(ctx, owner, expression, formulas, config)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ent.Owner, string, []*kaskadav1alpha.Formula, *kaskadav2alpha.QueryConfig) *kaskadav1alpha.CompileResponse); ok {
		r0 = rf(ctx, owner, expression, formulas, config)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kaskadav1alpha.CompileResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ent.Owner, string, []*kaskadav1alpha.Formula, *kaskadav2alpha.QueryConfig) error); ok {
		r1 = rf(ctx, owner, expression, formulas, config)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockComputeManager_CompileQueryV2_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompileQueryV2'
type MockComputeManager_CompileQueryV2_Call struct {
	*mock.Call
}

// CompileQueryV2 is a helper method to define mock.On call
//   - ctx context.Context
//   - owner *ent.Owner
//   - expression string
//   - formulas []*kaskadav1alpha.Formula
//   - config *kaskadav2alpha.QueryConfig
func (_e *MockComputeManager_Expecter) CompileQueryV2(ctx interface{}, owner interface{}, expression interface{}, formulas interface{}, config interface{}) *MockComputeManager_CompileQueryV2_Call {
	return &MockComputeManager_CompileQueryV2_Call{Call: _e.mock.On("CompileQueryV2", ctx, owner, expression, formulas, config)}
}

func (_c *MockComputeManager_CompileQueryV2_Call) Run(run func(ctx context.Context, owner *ent.Owner, expression string, formulas []*kaskadav1alpha.Formula, config *kaskadav2alpha.QueryConfig)) *MockComputeManager_CompileQueryV2_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*ent.Owner), args[2].(string), args[3].([]*kaskadav1alpha.Formula), args[4].(*kaskadav2alpha.QueryConfig))
	})
	return _c
}

func (_c *MockComputeManager_CompileQueryV2_Call) Return(_a0 *kaskadav1alpha.CompileResponse, _a1 error) *MockComputeManager_CompileQueryV2_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockComputeManager_CompileQueryV2_Call) RunAndReturn(run func(context.Context, *ent.Owner, string, []*kaskadav1alpha.Formula, *kaskadav2alpha.QueryConfig) (*kaskadav1alpha.CompileResponse, error)) *MockComputeManager_CompileQueryV2_Call {
	_c.Call.Return(run)
	return _c
}

// CreateCompileRequest provides a mock function with given fields: ctx, owner, request, options
func (_m *MockComputeManager) CreateCompileRequest(ctx context.Context, owner *ent.Owner, request *QueryRequest, options *QueryOptions) (*kaskadav1alpha.CompileRequest, error) {
	ret := _m.Called(ctx, owner, request, options)

	var r0 *kaskadav1alpha.CompileRequest
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ent.Owner, *QueryRequest, *QueryOptions) (*kaskadav1alpha.CompileRequest, error)); ok {
		return rf(ctx, owner, request, options)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ent.Owner, *QueryRequest, *QueryOptions) *kaskadav1alpha.CompileRequest); ok {
		r0 = rf(ctx, owner, request, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kaskadav1alpha.CompileRequest)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ent.Owner, *QueryRequest, *QueryOptions) error); ok {
		r1 = rf(ctx, owner, request, options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockComputeManager_CreateCompileRequest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateCompileRequest'
type MockComputeManager_CreateCompileRequest_Call struct {
	*mock.Call
}

// CreateCompileRequest is a helper method to define mock.On call
//   - ctx context.Context
//   - owner *ent.Owner
//   - request *QueryRequest
//   - options *QueryOptions
func (_e *MockComputeManager_Expecter) CreateCompileRequest(ctx interface{}, owner interface{}, request interface{}, options interface{}) *MockComputeManager_CreateCompileRequest_Call {
	return &MockComputeManager_CreateCompileRequest_Call{Call: _e.mock.On("CreateCompileRequest", ctx, owner, request, options)}
}

func (_c *MockComputeManager_CreateCompileRequest_Call) Run(run func(ctx context.Context, owner *ent.Owner, request *QueryRequest, options *QueryOptions)) *MockComputeManager_CreateCompileRequest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*ent.Owner), args[2].(*QueryRequest), args[3].(*QueryOptions))
	})
	return _c
}

func (_c *MockComputeManager_CreateCompileRequest_Call) Return(_a0 *kaskadav1alpha.CompileRequest, _a1 error) *MockComputeManager_CreateCompileRequest_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockComputeManager_CreateCompileRequest_Call) RunAndReturn(run func(context.Context, *ent.Owner, *QueryRequest, *QueryOptions) (*kaskadav1alpha.CompileRequest, error)) *MockComputeManager_CreateCompileRequest_Call {
	_c.Call.Return(run)
	return _c
}

// GetFileSchema provides a mock function with given fields: ctx, fileInput
func (_m *MockComputeManager) GetFileSchema(ctx context.Context, fileInput internal.FileInput) (*kaskadav1alpha.Schema, error) {
	ret := _m.Called(ctx, fileInput)

	var r0 *kaskadav1alpha.Schema
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, internal.FileInput) (*kaskadav1alpha.Schema, error)); ok {
		return rf(ctx, fileInput)
	}
	if rf, ok := ret.Get(0).(func(context.Context, internal.FileInput) *kaskadav1alpha.Schema); ok {
		r0 = rf(ctx, fileInput)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kaskadav1alpha.Schema)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, internal.FileInput) error); ok {
		r1 = rf(ctx, fileInput)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockComputeManager_GetFileSchema_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFileSchema'
type MockComputeManager_GetFileSchema_Call struct {
	*mock.Call
}

// GetFileSchema is a helper method to define mock.On call
//   - ctx context.Context
//   - fileInput internal.FileInput
func (_e *MockComputeManager_Expecter) GetFileSchema(ctx interface{}, fileInput interface{}) *MockComputeManager_GetFileSchema_Call {
	return &MockComputeManager_GetFileSchema_Call{Call: _e.mock.On("GetFileSchema", ctx, fileInput)}
}

func (_c *MockComputeManager_GetFileSchema_Call) Run(run func(ctx context.Context, fileInput internal.FileInput)) *MockComputeManager_GetFileSchema_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(internal.FileInput))
	})
	return _c
}

func (_c *MockComputeManager_GetFileSchema_Call) Return(_a0 *kaskadav1alpha.Schema, _a1 error) *MockComputeManager_GetFileSchema_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockComputeManager_GetFileSchema_Call) RunAndReturn(run func(context.Context, internal.FileInput) (*kaskadav1alpha.Schema, error)) *MockComputeManager_GetFileSchema_Call {
	_c.Call.Return(run)
	return _c
}

// GetFormulas provides a mock function with given fields: ctx, owner, views
func (_m *MockComputeManager) GetFormulas(ctx context.Context, owner *ent.Owner, views *kaskadav2alpha.QueryViews) ([]*kaskadav1alpha.Formula, error) {
	ret := _m.Called(ctx, owner, views)

	var r0 []*kaskadav1alpha.Formula
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ent.Owner, *kaskadav2alpha.QueryViews) ([]*kaskadav1alpha.Formula, error)); ok {
		return rf(ctx, owner, views)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ent.Owner, *kaskadav2alpha.QueryViews) []*kaskadav1alpha.Formula); ok {
		r0 = rf(ctx, owner, views)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*kaskadav1alpha.Formula)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ent.Owner, *kaskadav2alpha.QueryViews) error); ok {
		r1 = rf(ctx, owner, views)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockComputeManager_GetFormulas_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFormulas'
type MockComputeManager_GetFormulas_Call struct {
	*mock.Call
}

// GetFormulas is a helper method to define mock.On call
//   - ctx context.Context
//   - owner *ent.Owner
//   - views *kaskadav2alpha.QueryViews
func (_e *MockComputeManager_Expecter) GetFormulas(ctx interface{}, owner interface{}, views interface{}) *MockComputeManager_GetFormulas_Call {
	return &MockComputeManager_GetFormulas_Call{Call: _e.mock.On("GetFormulas", ctx, owner, views)}
}

func (_c *MockComputeManager_GetFormulas_Call) Run(run func(ctx context.Context, owner *ent.Owner, views *kaskadav2alpha.QueryViews)) *MockComputeManager_GetFormulas_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*ent.Owner), args[2].(*kaskadav2alpha.QueryViews))
	})
	return _c
}

func (_c *MockComputeManager_GetFormulas_Call) Return(_a0 []*kaskadav1alpha.Formula, _a1 error) *MockComputeManager_GetFormulas_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockComputeManager_GetFormulas_Call) RunAndReturn(run func(context.Context, *ent.Owner, *kaskadav2alpha.QueryViews) ([]*kaskadav1alpha.Formula, error)) *MockComputeManager_GetFormulas_Call {
	_c.Call.Return(run)
	return _c
}

// GetOutputURI provides a mock function with given fields: owner, planHash
func (_m *MockComputeManager) GetOutputURI(owner *ent.Owner, planHash []byte) string {
	ret := _m.Called(owner, planHash)

	var r0 string
	if rf, ok := ret.Get(0).(func(*ent.Owner, []byte) string); ok {
		r0 = rf(owner, planHash)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// MockComputeManager_GetOutputURI_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetOutputURI'
type MockComputeManager_GetOutputURI_Call struct {
	*mock.Call
}

// GetOutputURI is a helper method to define mock.On call
//   - owner *ent.Owner
//   - planHash []byte
func (_e *MockComputeManager_Expecter) GetOutputURI(owner interface{}, planHash interface{}) *MockComputeManager_GetOutputURI_Call {
	return &MockComputeManager_GetOutputURI_Call{Call: _e.mock.On("GetOutputURI", owner, planHash)}
}

func (_c *MockComputeManager_GetOutputURI_Call) Run(run func(owner *ent.Owner, planHash []byte)) *MockComputeManager_GetOutputURI_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*ent.Owner), args[1].([]byte))
	})
	return _c
}

func (_c *MockComputeManager_GetOutputURI_Call) Return(_a0 string) *MockComputeManager_GetOutputURI_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockComputeManager_GetOutputURI_Call) RunAndReturn(run func(*ent.Owner, []byte) string) *MockComputeManager_GetOutputURI_Call {
	_c.Call.Return(run)
	return _c
}

// GetTablesForCompute provides a mock function with given fields: ctx, owner, dataToken, slicePlans
func (_m *MockComputeManager) GetTablesForCompute(ctx context.Context, owner *ent.Owner, dataToken *ent.DataToken, slicePlans []*kaskadav1alpha.SlicePlan) (map[uuid.UUID]*internal.SliceTable, error) {
	ret := _m.Called(ctx, owner, dataToken, slicePlans)

	var r0 map[uuid.UUID]*internal.SliceTable
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ent.Owner, *ent.DataToken, []*kaskadav1alpha.SlicePlan) (map[uuid.UUID]*internal.SliceTable, error)); ok {
		return rf(ctx, owner, dataToken, slicePlans)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ent.Owner, *ent.DataToken, []*kaskadav1alpha.SlicePlan) map[uuid.UUID]*internal.SliceTable); ok {
		r0 = rf(ctx, owner, dataToken, slicePlans)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[uuid.UUID]*internal.SliceTable)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ent.Owner, *ent.DataToken, []*kaskadav1alpha.SlicePlan) error); ok {
		r1 = rf(ctx, owner, dataToken, slicePlans)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockComputeManager_GetTablesForCompute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTablesForCompute'
type MockComputeManager_GetTablesForCompute_Call struct {
	*mock.Call
}

// GetTablesForCompute is a helper method to define mock.On call
//   - ctx context.Context
//   - owner *ent.Owner
//   - dataToken *ent.DataToken
//   - slicePlans []*kaskadav1alpha.SlicePlan
func (_e *MockComputeManager_Expecter) GetTablesForCompute(ctx interface{}, owner interface{}, dataToken interface{}, slicePlans interface{}) *MockComputeManager_GetTablesForCompute_Call {
	return &MockComputeManager_GetTablesForCompute_Call{Call: _e.mock.On("GetTablesForCompute", ctx, owner, dataToken, slicePlans)}
}

func (_c *MockComputeManager_GetTablesForCompute_Call) Run(run func(ctx context.Context, owner *ent.Owner, dataToken *ent.DataToken, slicePlans []*kaskadav1alpha.SlicePlan)) *MockComputeManager_GetTablesForCompute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*ent.Owner), args[2].(*ent.DataToken), args[3].([]*kaskadav1alpha.SlicePlan))
	})
	return _c
}

func (_c *MockComputeManager_GetTablesForCompute_Call) Return(_a0 map[uuid.UUID]*internal.SliceTable, _a1 error) *MockComputeManager_GetTablesForCompute_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockComputeManager_GetTablesForCompute_Call) RunAndReturn(run func(context.Context, *ent.Owner, *ent.DataToken, []*kaskadav1alpha.SlicePlan) (map[uuid.UUID]*internal.SliceTable, error)) *MockComputeManager_GetTablesForCompute_Call {
	_c.Call.Return(run)
	return _c
}

// GetUsedViews provides a mock function with given fields: formulas, compileResponse
func (_m *MockComputeManager) GetUsedViews(formulas []*kaskadav1alpha.Formula, compileResponse *kaskadav1alpha.CompileResponse) *kaskadav2alpha.QueryViews {
	ret := _m.Called(formulas, compileResponse)

	var r0 *kaskadav2alpha.QueryViews
	if rf, ok := ret.Get(0).(func([]*kaskadav1alpha.Formula, *kaskadav1alpha.CompileResponse) *kaskadav2alpha.QueryViews); ok {
		r0 = rf(formulas, compileResponse)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*kaskadav2alpha.QueryViews)
		}
	}

	return r0
}

// MockComputeManager_GetUsedViews_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUsedViews'
type MockComputeManager_GetUsedViews_Call struct {
	*mock.Call
}

// GetUsedViews is a helper method to define mock.On call
//   - formulas []*kaskadav1alpha.Formula
//   - compileResponse *kaskadav1alpha.CompileResponse
func (_e *MockComputeManager_Expecter) GetUsedViews(formulas interface{}, compileResponse interface{}) *MockComputeManager_GetUsedViews_Call {
	return &MockComputeManager_GetUsedViews_Call{Call: _e.mock.On("GetUsedViews", formulas, compileResponse)}
}

func (_c *MockComputeManager_GetUsedViews_Call) Run(run func(formulas []*kaskadav1alpha.Formula, compileResponse *kaskadav1alpha.CompileResponse)) *MockComputeManager_GetUsedViews_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]*kaskadav1alpha.Formula), args[1].(*kaskadav1alpha.CompileResponse))
	})
	return _c
}

func (_c *MockComputeManager_GetUsedViews_Call) Return(_a0 *kaskadav2alpha.QueryViews) *MockComputeManager_GetUsedViews_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockComputeManager_GetUsedViews_Call) RunAndReturn(run func([]*kaskadav1alpha.Formula, *kaskadav1alpha.CompileResponse) *kaskadav2alpha.QueryViews) *MockComputeManager_GetUsedViews_Call {
	_c.Call.Return(run)
	return _c
}

// InitiateQuery provides a mock function with given fields: queryContext
func (_m *MockComputeManager) InitiateQuery(queryContext *QueryContext) (client.ComputeServiceClient, kaskadav1alpha.ComputeService_ExecuteClient, error) {
	ret := _m.Called(queryContext)

	var r0 client.ComputeServiceClient
	var r1 kaskadav1alpha.ComputeService_ExecuteClient
	var r2 error
	if rf, ok := ret.Get(0).(func(*QueryContext) (client.ComputeServiceClient, kaskadav1alpha.ComputeService_ExecuteClient, error)); ok {
		return rf(queryContext)
	}
	if rf, ok := ret.Get(0).(func(*QueryContext) client.ComputeServiceClient); ok {
		r0 = rf(queryContext)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(client.ComputeServiceClient)
		}
	}

	if rf, ok := ret.Get(1).(func(*QueryContext) kaskadav1alpha.ComputeService_ExecuteClient); ok {
		r1 = rf(queryContext)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(kaskadav1alpha.ComputeService_ExecuteClient)
		}
	}

	if rf, ok := ret.Get(2).(func(*QueryContext) error); ok {
		r2 = rf(queryContext)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockComputeManager_InitiateQuery_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InitiateQuery'
type MockComputeManager_InitiateQuery_Call struct {
	*mock.Call
}

// InitiateQuery is a helper method to define mock.On call
//   - queryContext *QueryContext
func (_e *MockComputeManager_Expecter) InitiateQuery(queryContext interface{}) *MockComputeManager_InitiateQuery_Call {
	return &MockComputeManager_InitiateQuery_Call{Call: _e.mock.On("InitiateQuery", queryContext)}
}

func (_c *MockComputeManager_InitiateQuery_Call) Run(run func(queryContext *QueryContext)) *MockComputeManager_InitiateQuery_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*QueryContext))
	})
	return _c
}

func (_c *MockComputeManager_InitiateQuery_Call) Return(_a0 client.ComputeServiceClient, _a1 kaskadav1alpha.ComputeService_ExecuteClient, _a2 error) *MockComputeManager_InitiateQuery_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockComputeManager_InitiateQuery_Call) RunAndReturn(run func(*QueryContext) (client.ComputeServiceClient, kaskadav1alpha.ComputeService_ExecuteClient, error)) *MockComputeManager_InitiateQuery_Call {
	_c.Call.Return(run)
	return _c
}

// RunCompileRequest provides a mock function with given fields: ctx, owner, compileRequest
func (_m *MockComputeManager) RunCompileRequest(ctx context.Context, owner *ent.Owner, compileRequest *kaskadav1alpha.CompileRequest) (*CompileQueryResponse, error) {
	ret := _m.Called(ctx, owner, compileRequest)

	var r0 *CompileQueryResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ent.Owner, *kaskadav1alpha.CompileRequest) (*CompileQueryResponse, error)); ok {
		return rf(ctx, owner, compileRequest)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ent.Owner, *kaskadav1alpha.CompileRequest) *CompileQueryResponse); ok {
		r0 = rf(ctx, owner, compileRequest)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*CompileQueryResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ent.Owner, *kaskadav1alpha.CompileRequest) error); ok {
		r1 = rf(ctx, owner, compileRequest)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockComputeManager_RunCompileRequest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RunCompileRequest'
type MockComputeManager_RunCompileRequest_Call struct {
	*mock.Call
}

// RunCompileRequest is a helper method to define mock.On call
//   - ctx context.Context
//   - owner *ent.Owner
//   - compileRequest *kaskadav1alpha.CompileRequest
func (_e *MockComputeManager_Expecter) RunCompileRequest(ctx interface{}, owner interface{}, compileRequest interface{}) *MockComputeManager_RunCompileRequest_Call {
	return &MockComputeManager_RunCompileRequest_Call{Call: _e.mock.On("RunCompileRequest", ctx, owner, compileRequest)}
}

func (_c *MockComputeManager_RunCompileRequest_Call) Run(run func(ctx context.Context, owner *ent.Owner, compileRequest *kaskadav1alpha.CompileRequest)) *MockComputeManager_RunCompileRequest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*ent.Owner), args[2].(*kaskadav1alpha.CompileRequest))
	})
	return _c
}

func (_c *MockComputeManager_RunCompileRequest_Call) Return(_a0 *CompileQueryResponse, _a1 error) *MockComputeManager_RunCompileRequest_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockComputeManager_RunCompileRequest_Call) RunAndReturn(run func(context.Context, *ent.Owner, *kaskadav1alpha.CompileRequest) (*CompileQueryResponse, error)) *MockComputeManager_RunCompileRequest_Call {
	_c.Call.Return(run)
	return _c
}

// RunMaterializations provides a mock function with given fields: requestCtx, owner
func (_m *MockComputeManager) RunMaterializations(requestCtx context.Context, owner *ent.Owner) {
	_m.Called(requestCtx, owner)
}

// MockComputeManager_RunMaterializations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RunMaterializations'
type MockComputeManager_RunMaterializations_Call struct {
	*mock.Call
}

// RunMaterializations is a helper method to define mock.On call
//   - requestCtx context.Context
//   - owner *ent.Owner
func (_e *MockComputeManager_Expecter) RunMaterializations(requestCtx interface{}, owner interface{}) *MockComputeManager_RunMaterializations_Call {
	return &MockComputeManager_RunMaterializations_Call{Call: _e.mock.On("RunMaterializations", requestCtx, owner)}
}

func (_c *MockComputeManager_RunMaterializations_Call) Run(run func(requestCtx context.Context, owner *ent.Owner)) *MockComputeManager_RunMaterializations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*ent.Owner))
	})
	return _c
}

func (_c *MockComputeManager_RunMaterializations_Call) Return() *MockComputeManager_RunMaterializations_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockComputeManager_RunMaterializations_Call) RunAndReturn(run func(context.Context, *ent.Owner)) *MockComputeManager_RunMaterializations_Call {
	_c.Call.Return(run)
	return _c
}

// SaveComputeSnapshots provides a mock function with given fields: queryContext, computeSnapshots
func (_m *MockComputeManager) SaveComputeSnapshots(queryContext *QueryContext, computeSnapshots []*kaskadav1alpha.ComputeSnapshot) {
	_m.Called(queryContext, computeSnapshots)
}

// MockComputeManager_SaveComputeSnapshots_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SaveComputeSnapshots'
type MockComputeManager_SaveComputeSnapshots_Call struct {
	*mock.Call
}

// SaveComputeSnapshots is a helper method to define mock.On call
//   - queryContext *QueryContext
//   - computeSnapshots []*kaskadav1alpha.ComputeSnapshot
func (_e *MockComputeManager_Expecter) SaveComputeSnapshots(queryContext interface{}, computeSnapshots interface{}) *MockComputeManager_SaveComputeSnapshots_Call {
	return &MockComputeManager_SaveComputeSnapshots_Call{Call: _e.mock.On("SaveComputeSnapshots", queryContext, computeSnapshots)}
}

func (_c *MockComputeManager_SaveComputeSnapshots_Call) Run(run func(queryContext *QueryContext, computeSnapshots []*kaskadav1alpha.ComputeSnapshot)) *MockComputeManager_SaveComputeSnapshots_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*QueryContext), args[1].([]*kaskadav1alpha.ComputeSnapshot))
	})
	return _c
}

func (_c *MockComputeManager_SaveComputeSnapshots_Call) Return() *MockComputeManager_SaveComputeSnapshots_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockComputeManager_SaveComputeSnapshots_Call) RunAndReturn(run func(*QueryContext, []*kaskadav1alpha.ComputeSnapshot)) *MockComputeManager_SaveComputeSnapshots_Call {
	_c.Call.Return(run)
	return _c
}

type mockConstructorTestingTNewMockComputeManager interface {
	mock.TestingT
	Cleanup(func())
}

// NewMockComputeManager creates a new instance of MockComputeManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewMockComputeManager(t mockConstructorTestingTNewMockComputeManager) *MockComputeManager {
	mock := &MockComputeManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
