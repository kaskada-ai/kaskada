// Code generated by mockery v2.27.1. DO NOT EDIT.

package internal

import (
	context "context"

	kaskadav1alpha "github.com/kaskada-ai/kaskada/gen/proto/go/kaskada/kaskada/v1alpha"
	ent "github.com/kaskada-ai/kaskada/wren/ent"

	mock "github.com/stretchr/testify/mock"

	time "time"

	uuid "github.com/google/uuid"
)

// MockKaskadaTableClient is an autogenerated mock type for the KaskadaTableClient type
type MockKaskadaTableClient struct {
	mock.Mock
}

type MockKaskadaTableClient_Expecter struct {
	mock *mock.Mock
}

func (_m *MockKaskadaTableClient) EXPECT() *MockKaskadaTableClient_Expecter {
	return &MockKaskadaTableClient_Expecter{mock: &_m.Mock}
}

// AddFilesToTable provides a mock function with given fields: ctx, owner, kaskadaTable, newFiles, newMergedSchema, newExternalVersion, cleanupOnError
func (_m *MockKaskadaTableClient) AddFilesToTable(ctx context.Context, owner *ent.Owner, kaskadaTable *ent.KaskadaTable, newFiles []AddFileProps, newMergedSchema *kaskadav1alpha.Schema, newExternalVersion *string, cleanupOnError func() error) (*ent.DataToken, error) {
	ret := _m.Called(ctx, owner, kaskadaTable, newFiles, newMergedSchema, newExternalVersion, cleanupOnError)

	var r0 *ent.DataToken
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ent.Owner, *ent.KaskadaTable, []AddFileProps, *kaskadav1alpha.Schema, *string, func() error) (*ent.DataToken, error)); ok {
		return rf(ctx, owner, kaskadaTable, newFiles, newMergedSchema, newExternalVersion, cleanupOnError)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ent.Owner, *ent.KaskadaTable, []AddFileProps, *kaskadav1alpha.Schema, *string, func() error) *ent.DataToken); ok {
		r0 = rf(ctx, owner, kaskadaTable, newFiles, newMergedSchema, newExternalVersion, cleanupOnError)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ent.DataToken)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ent.Owner, *ent.KaskadaTable, []AddFileProps, *kaskadav1alpha.Schema, *string, func() error) error); ok {
		r1 = rf(ctx, owner, kaskadaTable, newFiles, newMergedSchema, newExternalVersion, cleanupOnError)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockKaskadaTableClient_AddFilesToTable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddFilesToTable'
type MockKaskadaTableClient_AddFilesToTable_Call struct {
	*mock.Call
}

// AddFilesToTable is a helper method to define mock.On call
//   - ctx context.Context
//   - owner *ent.Owner
//   - kaskadaTable *ent.KaskadaTable
//   - newFiles []AddFileProps
//   - newMergedSchema *kaskadav1alpha.Schema
//   - newExternalVersion *string
//   - cleanupOnError func() error
func (_e *MockKaskadaTableClient_Expecter) AddFilesToTable(ctx interface{}, owner interface{}, kaskadaTable interface{}, newFiles interface{}, newMergedSchema interface{}, newExternalVersion interface{}, cleanupOnError interface{}) *MockKaskadaTableClient_AddFilesToTable_Call {
	return &MockKaskadaTableClient_AddFilesToTable_Call{Call: _e.mock.On("AddFilesToTable", ctx, owner, kaskadaTable, newFiles, newMergedSchema, newExternalVersion, cleanupOnError)}
}

func (_c *MockKaskadaTableClient_AddFilesToTable_Call) Run(run func(ctx context.Context, owner *ent.Owner, kaskadaTable *ent.KaskadaTable, newFiles []AddFileProps, newMergedSchema *kaskadav1alpha.Schema, newExternalVersion *string, cleanupOnError func() error)) *MockKaskadaTableClient_AddFilesToTable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*ent.Owner), args[2].(*ent.KaskadaTable), args[3].([]AddFileProps), args[4].(*kaskadav1alpha.Schema), args[5].(*string), args[6].(func() error))
	})
	return _c
}

func (_c *MockKaskadaTableClient_AddFilesToTable_Call) Return(_a0 *ent.DataToken, _a1 error) *MockKaskadaTableClient_AddFilesToTable_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockKaskadaTableClient_AddFilesToTable_Call) RunAndReturn(run func(context.Context, *ent.Owner, *ent.KaskadaTable, []AddFileProps, *kaskadav1alpha.Schema, *string, func() error) (*ent.DataToken, error)) *MockKaskadaTableClient_AddFilesToTable_Call {
	_c.Call.Return(run)
	return _c
}

// CreateKaskadaTable provides a mock function with given fields: ctx, owner, newTable
func (_m *MockKaskadaTableClient) CreateKaskadaTable(ctx context.Context, owner *ent.Owner, newTable *ent.KaskadaTable) (*ent.KaskadaTable, error) {
	ret := _m.Called(ctx, owner, newTable)

	var r0 *ent.KaskadaTable
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ent.Owner, *ent.KaskadaTable) (*ent.KaskadaTable, error)); ok {
		return rf(ctx, owner, newTable)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ent.Owner, *ent.KaskadaTable) *ent.KaskadaTable); ok {
		r0 = rf(ctx, owner, newTable)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ent.KaskadaTable)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ent.Owner, *ent.KaskadaTable) error); ok {
		r1 = rf(ctx, owner, newTable)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockKaskadaTableClient_CreateKaskadaTable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateKaskadaTable'
type MockKaskadaTableClient_CreateKaskadaTable_Call struct {
	*mock.Call
}

// CreateKaskadaTable is a helper method to define mock.On call
//   - ctx context.Context
//   - owner *ent.Owner
//   - newTable *ent.KaskadaTable
func (_e *MockKaskadaTableClient_Expecter) CreateKaskadaTable(ctx interface{}, owner interface{}, newTable interface{}) *MockKaskadaTableClient_CreateKaskadaTable_Call {
	return &MockKaskadaTableClient_CreateKaskadaTable_Call{Call: _e.mock.On("CreateKaskadaTable", ctx, owner, newTable)}
}

func (_c *MockKaskadaTableClient_CreateKaskadaTable_Call) Run(run func(ctx context.Context, owner *ent.Owner, newTable *ent.KaskadaTable)) *MockKaskadaTableClient_CreateKaskadaTable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*ent.Owner), args[2].(*ent.KaskadaTable))
	})
	return _c
}

func (_c *MockKaskadaTableClient_CreateKaskadaTable_Call) Return(_a0 *ent.KaskadaTable, _a1 error) *MockKaskadaTableClient_CreateKaskadaTable_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockKaskadaTableClient_CreateKaskadaTable_Call) RunAndReturn(run func(context.Context, *ent.Owner, *ent.KaskadaTable) (*ent.KaskadaTable, error)) *MockKaskadaTableClient_CreateKaskadaTable_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteKaskadaTable provides a mock function with given fields: ctx, owner, kaskadaTable
func (_m *MockKaskadaTableClient) DeleteKaskadaTable(ctx context.Context, owner *ent.Owner, kaskadaTable *ent.KaskadaTable) (*ent.DataToken, error) {
	ret := _m.Called(ctx, owner, kaskadaTable)

	var r0 *ent.DataToken
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ent.Owner, *ent.KaskadaTable) (*ent.DataToken, error)); ok {
		return rf(ctx, owner, kaskadaTable)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ent.Owner, *ent.KaskadaTable) *ent.DataToken); ok {
		r0 = rf(ctx, owner, kaskadaTable)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ent.DataToken)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ent.Owner, *ent.KaskadaTable) error); ok {
		r1 = rf(ctx, owner, kaskadaTable)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockKaskadaTableClient_DeleteKaskadaTable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteKaskadaTable'
type MockKaskadaTableClient_DeleteKaskadaTable_Call struct {
	*mock.Call
}

// DeleteKaskadaTable is a helper method to define mock.On call
//   - ctx context.Context
//   - owner *ent.Owner
//   - kaskadaTable *ent.KaskadaTable
func (_e *MockKaskadaTableClient_Expecter) DeleteKaskadaTable(ctx interface{}, owner interface{}, kaskadaTable interface{}) *MockKaskadaTableClient_DeleteKaskadaTable_Call {
	return &MockKaskadaTableClient_DeleteKaskadaTable_Call{Call: _e.mock.On("DeleteKaskadaTable", ctx, owner, kaskadaTable)}
}

func (_c *MockKaskadaTableClient_DeleteKaskadaTable_Call) Run(run func(ctx context.Context, owner *ent.Owner, kaskadaTable *ent.KaskadaTable)) *MockKaskadaTableClient_DeleteKaskadaTable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*ent.Owner), args[2].(*ent.KaskadaTable))
	})
	return _c
}

func (_c *MockKaskadaTableClient_DeleteKaskadaTable_Call) Return(_a0 *ent.DataToken, _a1 error) *MockKaskadaTableClient_DeleteKaskadaTable_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockKaskadaTableClient_DeleteKaskadaTable_Call) RunAndReturn(run func(context.Context, *ent.Owner, *ent.KaskadaTable) (*ent.DataToken, error)) *MockKaskadaTableClient_DeleteKaskadaTable_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllKaskadaTables provides a mock function with given fields: ctx, owner
func (_m *MockKaskadaTableClient) GetAllKaskadaTables(ctx context.Context, owner *ent.Owner) ([]*ent.KaskadaTable, error) {
	ret := _m.Called(ctx, owner)

	var r0 []*ent.KaskadaTable
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ent.Owner) ([]*ent.KaskadaTable, error)); ok {
		return rf(ctx, owner)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ent.Owner) []*ent.KaskadaTable); ok {
		r0 = rf(ctx, owner)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*ent.KaskadaTable)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ent.Owner) error); ok {
		r1 = rf(ctx, owner)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockKaskadaTableClient_GetAllKaskadaTables_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllKaskadaTables'
type MockKaskadaTableClient_GetAllKaskadaTables_Call struct {
	*mock.Call
}

// GetAllKaskadaTables is a helper method to define mock.On call
//   - ctx context.Context
//   - owner *ent.Owner
func (_e *MockKaskadaTableClient_Expecter) GetAllKaskadaTables(ctx interface{}, owner interface{}) *MockKaskadaTableClient_GetAllKaskadaTables_Call {
	return &MockKaskadaTableClient_GetAllKaskadaTables_Call{Call: _e.mock.On("GetAllKaskadaTables", ctx, owner)}
}

func (_c *MockKaskadaTableClient_GetAllKaskadaTables_Call) Run(run func(ctx context.Context, owner *ent.Owner)) *MockKaskadaTableClient_GetAllKaskadaTables_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*ent.Owner))
	})
	return _c
}

func (_c *MockKaskadaTableClient_GetAllKaskadaTables_Call) Return(_a0 []*ent.KaskadaTable, _a1 error) *MockKaskadaTableClient_GetAllKaskadaTables_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockKaskadaTableClient_GetAllKaskadaTables_Call) RunAndReturn(run func(context.Context, *ent.Owner) ([]*ent.KaskadaTable, error)) *MockKaskadaTableClient_GetAllKaskadaTables_Call {
	_c.Call.Return(run)
	return _c
}

// GetBestComputeSnapshot provides a mock function with given fields: ctx, owner, complilePlanHash, snapshotCacheBuster, slices, prepareCacheBuster
func (_m *MockKaskadaTableClient) GetBestComputeSnapshot(ctx context.Context, owner *ent.Owner, complilePlanHash []byte, snapshotCacheBuster int32, slices []*SliceInfo, prepareCacheBuster int32) (*ent.ComputeSnapshot, error) {
	ret := _m.Called(ctx, owner, complilePlanHash, snapshotCacheBuster, slices, prepareCacheBuster)

	var r0 *ent.ComputeSnapshot
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ent.Owner, []byte, int32, []*SliceInfo, int32) (*ent.ComputeSnapshot, error)); ok {
		return rf(ctx, owner, complilePlanHash, snapshotCacheBuster, slices, prepareCacheBuster)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ent.Owner, []byte, int32, []*SliceInfo, int32) *ent.ComputeSnapshot); ok {
		r0 = rf(ctx, owner, complilePlanHash, snapshotCacheBuster, slices, prepareCacheBuster)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ent.ComputeSnapshot)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ent.Owner, []byte, int32, []*SliceInfo, int32) error); ok {
		r1 = rf(ctx, owner, complilePlanHash, snapshotCacheBuster, slices, prepareCacheBuster)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockKaskadaTableClient_GetBestComputeSnapshot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBestComputeSnapshot'
type MockKaskadaTableClient_GetBestComputeSnapshot_Call struct {
	*mock.Call
}

// GetBestComputeSnapshot is a helper method to define mock.On call
//   - ctx context.Context
//   - owner *ent.Owner
//   - complilePlanHash []byte
//   - snapshotCacheBuster int32
//   - slices []*SliceInfo
//   - prepareCacheBuster int32
func (_e *MockKaskadaTableClient_Expecter) GetBestComputeSnapshot(ctx interface{}, owner interface{}, complilePlanHash interface{}, snapshotCacheBuster interface{}, slices interface{}, prepareCacheBuster interface{}) *MockKaskadaTableClient_GetBestComputeSnapshot_Call {
	return &MockKaskadaTableClient_GetBestComputeSnapshot_Call{Call: _e.mock.On("GetBestComputeSnapshot", ctx, owner, complilePlanHash, snapshotCacheBuster, slices, prepareCacheBuster)}
}

func (_c *MockKaskadaTableClient_GetBestComputeSnapshot_Call) Run(run func(ctx context.Context, owner *ent.Owner, complilePlanHash []byte, snapshotCacheBuster int32, slices []*SliceInfo, prepareCacheBuster int32)) *MockKaskadaTableClient_GetBestComputeSnapshot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*ent.Owner), args[2].([]byte), args[3].(int32), args[4].([]*SliceInfo), args[5].(int32))
	})
	return _c
}

func (_c *MockKaskadaTableClient_GetBestComputeSnapshot_Call) Return(_a0 *ent.ComputeSnapshot, _a1 error) *MockKaskadaTableClient_GetBestComputeSnapshot_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockKaskadaTableClient_GetBestComputeSnapshot_Call) RunAndReturn(run func(context.Context, *ent.Owner, []byte, int32, []*SliceInfo, int32) (*ent.ComputeSnapshot, error)) *MockKaskadaTableClient_GetBestComputeSnapshot_Call {
	_c.Call.Return(run)
	return _c
}

// GetKaskadaFiles provides a mock function with given fields: ctx, owner, kaskadaTable, dataToken
func (_m *MockKaskadaTableClient) GetKaskadaFiles(ctx context.Context, owner *ent.Owner, kaskadaTable *ent.KaskadaTable, dataToken *ent.DataToken) ([]*ent.KaskadaFile, error) {
	ret := _m.Called(ctx, owner, kaskadaTable, dataToken)

	var r0 []*ent.KaskadaFile
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ent.Owner, *ent.KaskadaTable, *ent.DataToken) ([]*ent.KaskadaFile, error)); ok {
		return rf(ctx, owner, kaskadaTable, dataToken)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ent.Owner, *ent.KaskadaTable, *ent.DataToken) []*ent.KaskadaFile); ok {
		r0 = rf(ctx, owner, kaskadaTable, dataToken)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*ent.KaskadaFile)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ent.Owner, *ent.KaskadaTable, *ent.DataToken) error); ok {
		r1 = rf(ctx, owner, kaskadaTable, dataToken)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockKaskadaTableClient_GetKaskadaFiles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetKaskadaFiles'
type MockKaskadaTableClient_GetKaskadaFiles_Call struct {
	*mock.Call
}

// GetKaskadaFiles is a helper method to define mock.On call
//   - ctx context.Context
//   - owner *ent.Owner
//   - kaskadaTable *ent.KaskadaTable
//   - dataToken *ent.DataToken
func (_e *MockKaskadaTableClient_Expecter) GetKaskadaFiles(ctx interface{}, owner interface{}, kaskadaTable interface{}, dataToken interface{}) *MockKaskadaTableClient_GetKaskadaFiles_Call {
	return &MockKaskadaTableClient_GetKaskadaFiles_Call{Call: _e.mock.On("GetKaskadaFiles", ctx, owner, kaskadaTable, dataToken)}
}

func (_c *MockKaskadaTableClient_GetKaskadaFiles_Call) Run(run func(ctx context.Context, owner *ent.Owner, kaskadaTable *ent.KaskadaTable, dataToken *ent.DataToken)) *MockKaskadaTableClient_GetKaskadaFiles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*ent.Owner), args[2].(*ent.KaskadaTable), args[3].(*ent.DataToken))
	})
	return _c
}

func (_c *MockKaskadaTableClient_GetKaskadaFiles_Call) Return(_a0 []*ent.KaskadaFile, _a1 error) *MockKaskadaTableClient_GetKaskadaFiles_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockKaskadaTableClient_GetKaskadaFiles_Call) RunAndReturn(run func(context.Context, *ent.Owner, *ent.KaskadaTable, *ent.DataToken) ([]*ent.KaskadaFile, error)) *MockKaskadaTableClient_GetKaskadaFiles_Call {
	_c.Call.Return(run)
	return _c
}

// GetKaskadaTable provides a mock function with given fields: ctx, owner, id
func (_m *MockKaskadaTableClient) GetKaskadaTable(ctx context.Context, owner *ent.Owner, id uuid.UUID) (*ent.KaskadaTable, error) {
	ret := _m.Called(ctx, owner, id)

	var r0 *ent.KaskadaTable
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ent.Owner, uuid.UUID) (*ent.KaskadaTable, error)); ok {
		return rf(ctx, owner, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ent.Owner, uuid.UUID) *ent.KaskadaTable); ok {
		r0 = rf(ctx, owner, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ent.KaskadaTable)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ent.Owner, uuid.UUID) error); ok {
		r1 = rf(ctx, owner, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockKaskadaTableClient_GetKaskadaTable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetKaskadaTable'
type MockKaskadaTableClient_GetKaskadaTable_Call struct {
	*mock.Call
}

// GetKaskadaTable is a helper method to define mock.On call
//   - ctx context.Context
//   - owner *ent.Owner
//   - id uuid.UUID
func (_e *MockKaskadaTableClient_Expecter) GetKaskadaTable(ctx interface{}, owner interface{}, id interface{}) *MockKaskadaTableClient_GetKaskadaTable_Call {
	return &MockKaskadaTableClient_GetKaskadaTable_Call{Call: _e.mock.On("GetKaskadaTable", ctx, owner, id)}
}

func (_c *MockKaskadaTableClient_GetKaskadaTable_Call) Run(run func(ctx context.Context, owner *ent.Owner, id uuid.UUID)) *MockKaskadaTableClient_GetKaskadaTable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*ent.Owner), args[2].(uuid.UUID))
	})
	return _c
}

func (_c *MockKaskadaTableClient_GetKaskadaTable_Call) Return(_a0 *ent.KaskadaTable, _a1 error) *MockKaskadaTableClient_GetKaskadaTable_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockKaskadaTableClient_GetKaskadaTable_Call) RunAndReturn(run func(context.Context, *ent.Owner, uuid.UUID) (*ent.KaskadaTable, error)) *MockKaskadaTableClient_GetKaskadaTable_Call {
	_c.Call.Return(run)
	return _c
}

// GetKaskadaTableByName provides a mock function with given fields: ctx, owner, name
func (_m *MockKaskadaTableClient) GetKaskadaTableByName(ctx context.Context, owner *ent.Owner, name string) (*ent.KaskadaTable, error) {
	ret := _m.Called(ctx, owner, name)

	var r0 *ent.KaskadaTable
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ent.Owner, string) (*ent.KaskadaTable, error)); ok {
		return rf(ctx, owner, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ent.Owner, string) *ent.KaskadaTable); ok {
		r0 = rf(ctx, owner, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ent.KaskadaTable)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ent.Owner, string) error); ok {
		r1 = rf(ctx, owner, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockKaskadaTableClient_GetKaskadaTableByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetKaskadaTableByName'
type MockKaskadaTableClient_GetKaskadaTableByName_Call struct {
	*mock.Call
}

// GetKaskadaTableByName is a helper method to define mock.On call
//   - ctx context.Context
//   - owner *ent.Owner
//   - name string
func (_e *MockKaskadaTableClient_Expecter) GetKaskadaTableByName(ctx interface{}, owner interface{}, name interface{}) *MockKaskadaTableClient_GetKaskadaTableByName_Call {
	return &MockKaskadaTableClient_GetKaskadaTableByName_Call{Call: _e.mock.On("GetKaskadaTableByName", ctx, owner, name)}
}

func (_c *MockKaskadaTableClient_GetKaskadaTableByName_Call) Run(run func(ctx context.Context, owner *ent.Owner, name string)) *MockKaskadaTableClient_GetKaskadaTableByName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*ent.Owner), args[2].(string))
	})
	return _c
}

func (_c *MockKaskadaTableClient_GetKaskadaTableByName_Call) Return(_a0 *ent.KaskadaTable, _a1 error) *MockKaskadaTableClient_GetKaskadaTableByName_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockKaskadaTableClient_GetKaskadaTableByName_Call) RunAndReturn(run func(context.Context, *ent.Owner, string) (*ent.KaskadaTable, error)) *MockKaskadaTableClient_GetKaskadaTableByName_Call {
	_c.Call.Return(run)
	return _c
}

// GetKaskadaTableVersion provides a mock function with given fields: ctx, kaskadaTable
func (_m *MockKaskadaTableClient) GetKaskadaTableVersion(ctx context.Context, kaskadaTable *ent.KaskadaTable) (*ent.DataVersion, error) {
	ret := _m.Called(ctx, kaskadaTable)

	var r0 *ent.DataVersion
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ent.KaskadaTable) (*ent.DataVersion, error)); ok {
		return rf(ctx, kaskadaTable)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ent.KaskadaTable) *ent.DataVersion); ok {
		r0 = rf(ctx, kaskadaTable)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ent.DataVersion)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ent.KaskadaTable) error); ok {
		r1 = rf(ctx, kaskadaTable)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockKaskadaTableClient_GetKaskadaTableVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetKaskadaTableVersion'
type MockKaskadaTableClient_GetKaskadaTableVersion_Call struct {
	*mock.Call
}

// GetKaskadaTableVersion is a helper method to define mock.On call
//   - ctx context.Context
//   - kaskadaTable *ent.KaskadaTable
func (_e *MockKaskadaTableClient_Expecter) GetKaskadaTableVersion(ctx interface{}, kaskadaTable interface{}) *MockKaskadaTableClient_GetKaskadaTableVersion_Call {
	return &MockKaskadaTableClient_GetKaskadaTableVersion_Call{Call: _e.mock.On("GetKaskadaTableVersion", ctx, kaskadaTable)}
}

func (_c *MockKaskadaTableClient_GetKaskadaTableVersion_Call) Run(run func(ctx context.Context, kaskadaTable *ent.KaskadaTable)) *MockKaskadaTableClient_GetKaskadaTableVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*ent.KaskadaTable))
	})
	return _c
}

func (_c *MockKaskadaTableClient_GetKaskadaTableVersion_Call) Return(_a0 *ent.DataVersion, _a1 error) *MockKaskadaTableClient_GetKaskadaTableVersion_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockKaskadaTableClient_GetKaskadaTableVersion_Call) RunAndReturn(run func(context.Context, *ent.KaskadaTable) (*ent.DataVersion, error)) *MockKaskadaTableClient_GetKaskadaTableVersion_Call {
	_c.Call.Return(run)
	return _c
}

// GetKaskadaTablesFromNames provides a mock function with given fields: ctx, owner, names
func (_m *MockKaskadaTableClient) GetKaskadaTablesFromNames(ctx context.Context, owner *ent.Owner, names []string) (map[string]*ent.KaskadaTable, error) {
	ret := _m.Called(ctx, owner, names)

	var r0 map[string]*ent.KaskadaTable
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ent.Owner, []string) (map[string]*ent.KaskadaTable, error)); ok {
		return rf(ctx, owner, names)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ent.Owner, []string) map[string]*ent.KaskadaTable); ok {
		r0 = rf(ctx, owner, names)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]*ent.KaskadaTable)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ent.Owner, []string) error); ok {
		r1 = rf(ctx, owner, names)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockKaskadaTableClient_GetKaskadaTablesFromNames_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetKaskadaTablesFromNames'
type MockKaskadaTableClient_GetKaskadaTablesFromNames_Call struct {
	*mock.Call
}

// GetKaskadaTablesFromNames is a helper method to define mock.On call
//   - ctx context.Context
//   - owner *ent.Owner
//   - names []string
func (_e *MockKaskadaTableClient_Expecter) GetKaskadaTablesFromNames(ctx interface{}, owner interface{}, names interface{}) *MockKaskadaTableClient_GetKaskadaTablesFromNames_Call {
	return &MockKaskadaTableClient_GetKaskadaTablesFromNames_Call{Call: _e.mock.On("GetKaskadaTablesFromNames", ctx, owner, names)}
}

func (_c *MockKaskadaTableClient_GetKaskadaTablesFromNames_Call) Run(run func(ctx context.Context, owner *ent.Owner, names []string)) *MockKaskadaTableClient_GetKaskadaTablesFromNames_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*ent.Owner), args[2].([]string))
	})
	return _c
}

func (_c *MockKaskadaTableClient_GetKaskadaTablesFromNames_Call) Return(_a0 map[string]*ent.KaskadaTable, _a1 error) *MockKaskadaTableClient_GetKaskadaTablesFromNames_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockKaskadaTableClient_GetKaskadaTablesFromNames_Call) RunAndReturn(run func(context.Context, *ent.Owner, []string) (map[string]*ent.KaskadaTable, error)) *MockKaskadaTableClient_GetKaskadaTablesFromNames_Call {
	_c.Call.Return(run)
	return _c
}

// GetMinTimeOfNewPreparedFiles provides a mock function with given fields: ctx, prepareCacheBuster, sliceInfo, dataVersion
func (_m *MockKaskadaTableClient) GetMinTimeOfNewPreparedFiles(ctx context.Context, prepareCacheBuster int32, sliceInfo *SliceInfo, dataVersion int64) (*int64, error) {
	ret := _m.Called(ctx, prepareCacheBuster, sliceInfo, dataVersion)

	var r0 *int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int32, *SliceInfo, int64) (*int64, error)); ok {
		return rf(ctx, prepareCacheBuster, sliceInfo, dataVersion)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int32, *SliceInfo, int64) *int64); ok {
		r0 = rf(ctx, prepareCacheBuster, sliceInfo, dataVersion)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*int64)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int32, *SliceInfo, int64) error); ok {
		r1 = rf(ctx, prepareCacheBuster, sliceInfo, dataVersion)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockKaskadaTableClient_GetMinTimeOfNewPreparedFiles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMinTimeOfNewPreparedFiles'
type MockKaskadaTableClient_GetMinTimeOfNewPreparedFiles_Call struct {
	*mock.Call
}

// GetMinTimeOfNewPreparedFiles is a helper method to define mock.On call
//   - ctx context.Context
//   - prepareCacheBuster int32
//   - sliceInfo *SliceInfo
//   - dataVersion int64
func (_e *MockKaskadaTableClient_Expecter) GetMinTimeOfNewPreparedFiles(ctx interface{}, prepareCacheBuster interface{}, sliceInfo interface{}, dataVersion interface{}) *MockKaskadaTableClient_GetMinTimeOfNewPreparedFiles_Call {
	return &MockKaskadaTableClient_GetMinTimeOfNewPreparedFiles_Call{Call: _e.mock.On("GetMinTimeOfNewPreparedFiles", ctx, prepareCacheBuster, sliceInfo, dataVersion)}
}

func (_c *MockKaskadaTableClient_GetMinTimeOfNewPreparedFiles_Call) Run(run func(ctx context.Context, prepareCacheBuster int32, sliceInfo *SliceInfo, dataVersion int64)) *MockKaskadaTableClient_GetMinTimeOfNewPreparedFiles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int32), args[2].(*SliceInfo), args[3].(int64))
	})
	return _c
}

func (_c *MockKaskadaTableClient_GetMinTimeOfNewPreparedFiles_Call) Return(_a0 *int64, _a1 error) *MockKaskadaTableClient_GetMinTimeOfNewPreparedFiles_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockKaskadaTableClient_GetMinTimeOfNewPreparedFiles_Call) RunAndReturn(run func(context.Context, int32, *SliceInfo, int64) (*int64, error)) *MockKaskadaTableClient_GetMinTimeOfNewPreparedFiles_Call {
	_c.Call.Return(run)
	return _c
}

// ListKaskadaTables provides a mock function with given fields: ctx, owner, searchTerm, pageSize, offset
func (_m *MockKaskadaTableClient) ListKaskadaTables(ctx context.Context, owner *ent.Owner, searchTerm string, pageSize int, offset int) ([]*ent.KaskadaTable, error) {
	ret := _m.Called(ctx, owner, searchTerm, pageSize, offset)

	var r0 []*ent.KaskadaTable
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ent.Owner, string, int, int) ([]*ent.KaskadaTable, error)); ok {
		return rf(ctx, owner, searchTerm, pageSize, offset)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ent.Owner, string, int, int) []*ent.KaskadaTable); ok {
		r0 = rf(ctx, owner, searchTerm, pageSize, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*ent.KaskadaTable)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ent.Owner, string, int, int) error); ok {
		r1 = rf(ctx, owner, searchTerm, pageSize, offset)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockKaskadaTableClient_ListKaskadaTables_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListKaskadaTables'
type MockKaskadaTableClient_ListKaskadaTables_Call struct {
	*mock.Call
}

// ListKaskadaTables is a helper method to define mock.On call
//   - ctx context.Context
//   - owner *ent.Owner
//   - searchTerm string
//   - pageSize int
//   - offset int
func (_e *MockKaskadaTableClient_Expecter) ListKaskadaTables(ctx interface{}, owner interface{}, searchTerm interface{}, pageSize interface{}, offset interface{}) *MockKaskadaTableClient_ListKaskadaTables_Call {
	return &MockKaskadaTableClient_ListKaskadaTables_Call{Call: _e.mock.On("ListKaskadaTables", ctx, owner, searchTerm, pageSize, offset)}
}

func (_c *MockKaskadaTableClient_ListKaskadaTables_Call) Run(run func(ctx context.Context, owner *ent.Owner, searchTerm string, pageSize int, offset int)) *MockKaskadaTableClient_ListKaskadaTables_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*ent.Owner), args[2].(string), args[3].(int), args[4].(int))
	})
	return _c
}

func (_c *MockKaskadaTableClient_ListKaskadaTables_Call) Return(_a0 []*ent.KaskadaTable, _a1 error) *MockKaskadaTableClient_ListKaskadaTables_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockKaskadaTableClient_ListKaskadaTables_Call) RunAndReturn(run func(context.Context, *ent.Owner, string, int, int) ([]*ent.KaskadaTable, error)) *MockKaskadaTableClient_ListKaskadaTables_Call {
	_c.Call.Return(run)
	return _c
}

// SaveComputeSnapshot provides a mock function with given fields: ctx, owner, complilePlanHash, snapshotCacheBuster, dataToken, path, maxEventTime, relatedTablesIDs
func (_m *MockKaskadaTableClient) SaveComputeSnapshot(ctx context.Context, owner *ent.Owner, complilePlanHash []byte, snapshotCacheBuster int32, dataToken *ent.DataToken, path string, maxEventTime time.Time, relatedTablesIDs []uuid.UUID) error {
	ret := _m.Called(ctx, owner, complilePlanHash, snapshotCacheBuster, dataToken, path, maxEventTime, relatedTablesIDs)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *ent.Owner, []byte, int32, *ent.DataToken, string, time.Time, []uuid.UUID) error); ok {
		r0 = rf(ctx, owner, complilePlanHash, snapshotCacheBuster, dataToken, path, maxEventTime, relatedTablesIDs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockKaskadaTableClient_SaveComputeSnapshot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SaveComputeSnapshot'
type MockKaskadaTableClient_SaveComputeSnapshot_Call struct {
	*mock.Call
}

// SaveComputeSnapshot is a helper method to define mock.On call
//   - ctx context.Context
//   - owner *ent.Owner
//   - complilePlanHash []byte
//   - snapshotCacheBuster int32
//   - dataToken *ent.DataToken
//   - path string
//   - maxEventTime time.Time
//   - relatedTablesIDs []uuid.UUID
func (_e *MockKaskadaTableClient_Expecter) SaveComputeSnapshot(ctx interface{}, owner interface{}, complilePlanHash interface{}, snapshotCacheBuster interface{}, dataToken interface{}, path interface{}, maxEventTime interface{}, relatedTablesIDs interface{}) *MockKaskadaTableClient_SaveComputeSnapshot_Call {
	return &MockKaskadaTableClient_SaveComputeSnapshot_Call{Call: _e.mock.On("SaveComputeSnapshot", ctx, owner, complilePlanHash, snapshotCacheBuster, dataToken, path, maxEventTime, relatedTablesIDs)}
}

func (_c *MockKaskadaTableClient_SaveComputeSnapshot_Call) Run(run func(ctx context.Context, owner *ent.Owner, complilePlanHash []byte, snapshotCacheBuster int32, dataToken *ent.DataToken, path string, maxEventTime time.Time, relatedTablesIDs []uuid.UUID)) *MockKaskadaTableClient_SaveComputeSnapshot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*ent.Owner), args[2].([]byte), args[3].(int32), args[4].(*ent.DataToken), args[5].(string), args[6].(time.Time), args[7].([]uuid.UUID))
	})
	return _c
}

func (_c *MockKaskadaTableClient_SaveComputeSnapshot_Call) Return(_a0 error) *MockKaskadaTableClient_SaveComputeSnapshot_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockKaskadaTableClient_SaveComputeSnapshot_Call) RunAndReturn(run func(context.Context, *ent.Owner, []byte, int32, *ent.DataToken, string, time.Time, []uuid.UUID) error) *MockKaskadaTableClient_SaveComputeSnapshot_Call {
	_c.Call.Return(run)
	return _c
}

type mockConstructorTestingTNewMockKaskadaTableClient interface {
	mock.TestingT
	Cleanup(func())
}

// NewMockKaskadaTableClient creates a new instance of MockKaskadaTableClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewMockKaskadaTableClient(t mockConstructorTestingTNewMockKaskadaTableClient) *MockKaskadaTableClient {
	mock := &MockKaskadaTableClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
