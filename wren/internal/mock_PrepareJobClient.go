// Code generated by mockery v2.27.1. DO NOT EDIT.

package internal

import (
	context "context"

	kaskadav1alpha "github.com/kaskada-ai/kaskada/gen/proto/go/kaskada/kaskada/v1alpha"
	ent "github.com/kaskada-ai/kaskada/wren/ent"

	mock "github.com/stretchr/testify/mock"

	predicate "github.com/kaskada-ai/kaskada/wren/ent/predicate"

	property "github.com/kaskada-ai/kaskada/wren/property"

	uuid "github.com/google/uuid"
)

// MockPrepareJobClient is an autogenerated mock type for the PrepareJobClient type
type MockPrepareJobClient struct {
	mock.Mock
}

type MockPrepareJobClient_Expecter struct {
	mock *mock.Mock
}

func (_m *MockPrepareJobClient) EXPECT() *MockPrepareJobClient_Expecter {
	return &MockPrepareJobClient_Expecter{mock: &_m.Mock}
}

// AddFilesToPrepareJob provides a mock function with given fields: ctx, prepareJob, preparedFilesToCreateAndAttach, relatedKaskadaFile
func (_m *MockPrepareJobClient) AddFilesToPrepareJob(ctx context.Context, prepareJob *ent.PrepareJob, preparedFilesToCreateAndAttach []*kaskadav1alpha.PreparedFile, relatedKaskadaFile *ent.KaskadaFile) error {
	ret := _m.Called(ctx, prepareJob, preparedFilesToCreateAndAttach, relatedKaskadaFile)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *ent.PrepareJob, []*kaskadav1alpha.PreparedFile, *ent.KaskadaFile) error); ok {
		r0 = rf(ctx, prepareJob, preparedFilesToCreateAndAttach, relatedKaskadaFile)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockPrepareJobClient_AddFilesToPrepareJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddFilesToPrepareJob'
type MockPrepareJobClient_AddFilesToPrepareJob_Call struct {
	*mock.Call
}

// AddFilesToPrepareJob is a helper method to define mock.On call
//   - ctx context.Context
//   - prepareJob *ent.PrepareJob
//   - preparedFilesToCreateAndAttach []*kaskadav1alpha.PreparedFile
//   - relatedKaskadaFile *ent.KaskadaFile
func (_e *MockPrepareJobClient_Expecter) AddFilesToPrepareJob(ctx interface{}, prepareJob interface{}, preparedFilesToCreateAndAttach interface{}, relatedKaskadaFile interface{}) *MockPrepareJobClient_AddFilesToPrepareJob_Call {
	return &MockPrepareJobClient_AddFilesToPrepareJob_Call{Call: _e.mock.On("AddFilesToPrepareJob", ctx, prepareJob, preparedFilesToCreateAndAttach, relatedKaskadaFile)}
}

func (_c *MockPrepareJobClient_AddFilesToPrepareJob_Call) Run(run func(ctx context.Context, prepareJob *ent.PrepareJob, preparedFilesToCreateAndAttach []*kaskadav1alpha.PreparedFile, relatedKaskadaFile *ent.KaskadaFile)) *MockPrepareJobClient_AddFilesToPrepareJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*ent.PrepareJob), args[2].([]*kaskadav1alpha.PreparedFile), args[3].(*ent.KaskadaFile))
	})
	return _c
}

func (_c *MockPrepareJobClient_AddFilesToPrepareJob_Call) Return(_a0 error) *MockPrepareJobClient_AddFilesToPrepareJob_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPrepareJobClient_AddFilesToPrepareJob_Call) RunAndReturn(run func(context.Context, *ent.PrepareJob, []*kaskadav1alpha.PreparedFile, *ent.KaskadaFile) error) *MockPrepareJobClient_AddFilesToPrepareJob_Call {
	_c.Call.Return(run)
	return _c
}

// CreatePrepareJob provides a mock function with given fields: ctx, kaskadaFiles, sliceInfo, prepareCacheBuster, state
func (_m *MockPrepareJobClient) CreatePrepareJob(ctx context.Context, kaskadaFiles []*ent.KaskadaFile, sliceInfo *SliceInfo, prepareCacheBuster int32, state property.PrepareJobState) (*ent.PrepareJob, error) {
	ret := _m.Called(ctx, kaskadaFiles, sliceInfo, prepareCacheBuster, state)

	var r0 *ent.PrepareJob
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []*ent.KaskadaFile, *SliceInfo, int32, property.PrepareJobState) (*ent.PrepareJob, error)); ok {
		return rf(ctx, kaskadaFiles, sliceInfo, prepareCacheBuster, state)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []*ent.KaskadaFile, *SliceInfo, int32, property.PrepareJobState) *ent.PrepareJob); ok {
		r0 = rf(ctx, kaskadaFiles, sliceInfo, prepareCacheBuster, state)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ent.PrepareJob)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []*ent.KaskadaFile, *SliceInfo, int32, property.PrepareJobState) error); ok {
		r1 = rf(ctx, kaskadaFiles, sliceInfo, prepareCacheBuster, state)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPrepareJobClient_CreatePrepareJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreatePrepareJob'
type MockPrepareJobClient_CreatePrepareJob_Call struct {
	*mock.Call
}

// CreatePrepareJob is a helper method to define mock.On call
//   - ctx context.Context
//   - kaskadaFiles []*ent.KaskadaFile
//   - sliceInfo *SliceInfo
//   - prepareCacheBuster int32
//   - state property.PrepareJobState
func (_e *MockPrepareJobClient_Expecter) CreatePrepareJob(ctx interface{}, kaskadaFiles interface{}, sliceInfo interface{}, prepareCacheBuster interface{}, state interface{}) *MockPrepareJobClient_CreatePrepareJob_Call {
	return &MockPrepareJobClient_CreatePrepareJob_Call{Call: _e.mock.On("CreatePrepareJob", ctx, kaskadaFiles, sliceInfo, prepareCacheBuster, state)}
}

func (_c *MockPrepareJobClient_CreatePrepareJob_Call) Run(run func(ctx context.Context, kaskadaFiles []*ent.KaskadaFile, sliceInfo *SliceInfo, prepareCacheBuster int32, state property.PrepareJobState)) *MockPrepareJobClient_CreatePrepareJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]*ent.KaskadaFile), args[2].(*SliceInfo), args[3].(int32), args[4].(property.PrepareJobState))
	})
	return _c
}

func (_c *MockPrepareJobClient_CreatePrepareJob_Call) Return(_a0 *ent.PrepareJob, _a1 error) *MockPrepareJobClient_CreatePrepareJob_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPrepareJobClient_CreatePrepareJob_Call) RunAndReturn(run func(context.Context, []*ent.KaskadaFile, *SliceInfo, int32, property.PrepareJobState) (*ent.PrepareJob, error)) *MockPrepareJobClient_CreatePrepareJob_Call {
	_c.Call.Return(run)
	return _c
}

// GetPrepareJob provides a mock function with given fields: ctx, id
func (_m *MockPrepareJobClient) GetPrepareJob(ctx context.Context, id uuid.UUID) (*ent.PrepareJob, error) {
	ret := _m.Called(ctx, id)

	var r0 *ent.PrepareJob
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*ent.PrepareJob, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) *ent.PrepareJob); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ent.PrepareJob)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPrepareJobClient_GetPrepareJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPrepareJob'
type MockPrepareJobClient_GetPrepareJob_Call struct {
	*mock.Call
}

// GetPrepareJob is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *MockPrepareJobClient_Expecter) GetPrepareJob(ctx interface{}, id interface{}) *MockPrepareJobClient_GetPrepareJob_Call {
	return &MockPrepareJobClient_GetPrepareJob_Call{Call: _e.mock.On("GetPrepareJob", ctx, id)}
}

func (_c *MockPrepareJobClient_GetPrepareJob_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockPrepareJobClient_GetPrepareJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockPrepareJobClient_GetPrepareJob_Call) Return(_a0 *ent.PrepareJob, _a1 error) *MockPrepareJobClient_GetPrepareJob_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPrepareJobClient_GetPrepareJob_Call) RunAndReturn(run func(context.Context, uuid.UUID) (*ent.PrepareJob, error)) *MockPrepareJobClient_GetPrepareJob_Call {
	_c.Call.Return(run)
	return _c
}

// ListPrepareJobs provides a mock function with given fields: ctx, kaskadaFiles, sliceInfo, prepareCacheBuster, additonalFilters
func (_m *MockPrepareJobClient) ListPrepareJobs(ctx context.Context, kaskadaFiles []*ent.KaskadaFile, sliceInfo *SliceInfo, prepareCacheBuster int32, additonalFilters ...predicate.PrepareJob) ([]*ent.PrepareJob, error) {
	_va := make([]interface{}, len(additonalFilters))
	for _i := range additonalFilters {
		_va[_i] = additonalFilters[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, kaskadaFiles, sliceInfo, prepareCacheBuster)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 []*ent.PrepareJob
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []*ent.KaskadaFile, *SliceInfo, int32, ...predicate.PrepareJob) ([]*ent.PrepareJob, error)); ok {
		return rf(ctx, kaskadaFiles, sliceInfo, prepareCacheBuster, additonalFilters...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []*ent.KaskadaFile, *SliceInfo, int32, ...predicate.PrepareJob) []*ent.PrepareJob); ok {
		r0 = rf(ctx, kaskadaFiles, sliceInfo, prepareCacheBuster, additonalFilters...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*ent.PrepareJob)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []*ent.KaskadaFile, *SliceInfo, int32, ...predicate.PrepareJob) error); ok {
		r1 = rf(ctx, kaskadaFiles, sliceInfo, prepareCacheBuster, additonalFilters...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPrepareJobClient_ListPrepareJobs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListPrepareJobs'
type MockPrepareJobClient_ListPrepareJobs_Call struct {
	*mock.Call
}

// ListPrepareJobs is a helper method to define mock.On call
//   - ctx context.Context
//   - kaskadaFiles []*ent.KaskadaFile
//   - sliceInfo *SliceInfo
//   - prepareCacheBuster int32
//   - additonalFilters ...predicate.PrepareJob
func (_e *MockPrepareJobClient_Expecter) ListPrepareJobs(ctx interface{}, kaskadaFiles interface{}, sliceInfo interface{}, prepareCacheBuster interface{}, additonalFilters ...interface{}) *MockPrepareJobClient_ListPrepareJobs_Call {
	return &MockPrepareJobClient_ListPrepareJobs_Call{Call: _e.mock.On("ListPrepareJobs",
		append([]interface{}{ctx, kaskadaFiles, sliceInfo, prepareCacheBuster}, additonalFilters...)...)}
}

func (_c *MockPrepareJobClient_ListPrepareJobs_Call) Run(run func(ctx context.Context, kaskadaFiles []*ent.KaskadaFile, sliceInfo *SliceInfo, prepareCacheBuster int32, additonalFilters ...predicate.PrepareJob)) *MockPrepareJobClient_ListPrepareJobs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]predicate.PrepareJob, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(predicate.PrepareJob)
			}
		}
		run(args[0].(context.Context), args[1].([]*ent.KaskadaFile), args[2].(*SliceInfo), args[3].(int32), variadicArgs...)
	})
	return _c
}

func (_c *MockPrepareJobClient_ListPrepareJobs_Call) Return(_a0 []*ent.PrepareJob, _a1 error) *MockPrepareJobClient_ListPrepareJobs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPrepareJobClient_ListPrepareJobs_Call) RunAndReturn(run func(context.Context, []*ent.KaskadaFile, *SliceInfo, int32, ...predicate.PrepareJob) ([]*ent.PrepareJob, error)) *MockPrepareJobClient_ListPrepareJobs_Call {
	_c.Call.Return(run)
	return _c
}

// UpdatePrepareJobState provides a mock function with given fields: ctx, prepareJob, newState
func (_m *MockPrepareJobClient) UpdatePrepareJobState(ctx context.Context, prepareJob *ent.PrepareJob, newState property.PrepareJobState) error {
	ret := _m.Called(ctx, prepareJob, newState)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *ent.PrepareJob, property.PrepareJobState) error); ok {
		r0 = rf(ctx, prepareJob, newState)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockPrepareJobClient_UpdatePrepareJobState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdatePrepareJobState'
type MockPrepareJobClient_UpdatePrepareJobState_Call struct {
	*mock.Call
}

// UpdatePrepareJobState is a helper method to define mock.On call
//   - ctx context.Context
//   - prepareJob *ent.PrepareJob
//   - newState property.PrepareJobState
func (_e *MockPrepareJobClient_Expecter) UpdatePrepareJobState(ctx interface{}, prepareJob interface{}, newState interface{}) *MockPrepareJobClient_UpdatePrepareJobState_Call {
	return &MockPrepareJobClient_UpdatePrepareJobState_Call{Call: _e.mock.On("UpdatePrepareJobState", ctx, prepareJob, newState)}
}

func (_c *MockPrepareJobClient_UpdatePrepareJobState_Call) Run(run func(ctx context.Context, prepareJob *ent.PrepareJob, newState property.PrepareJobState)) *MockPrepareJobClient_UpdatePrepareJobState_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*ent.PrepareJob), args[2].(property.PrepareJobState))
	})
	return _c
}

func (_c *MockPrepareJobClient_UpdatePrepareJobState_Call) Return(_a0 error) *MockPrepareJobClient_UpdatePrepareJobState_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPrepareJobClient_UpdatePrepareJobState_Call) RunAndReturn(run func(context.Context, *ent.PrepareJob, property.PrepareJobState) error) *MockPrepareJobClient_UpdatePrepareJobState_Call {
	_c.Call.Return(run)
	return _c
}

type mockConstructorTestingTNewMockPrepareJobClient interface {
	mock.TestingT
	Cleanup(func())
}

// NewMockPrepareJobClient creates a new instance of MockPrepareJobClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewMockPrepareJobClient(t mockConstructorTestingTNewMockPrepareJobClient) *MockPrepareJobClient {
	mock := &MockPrepareJobClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
