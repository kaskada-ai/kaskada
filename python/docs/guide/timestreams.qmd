---
title: Timestreams
---

# Timestreams

Understanding and reacting to the world in real-time requires understanding what is happening _now_ in the context of what happened in the past.
You need the ability to understand if what just happened is unusual, how it relates to what happened previously, and how it relates to other things that are happening at the same time.

Kaskada processes events from streams and historic data sources to answer these questions in real-time.

The power and convenience of Kaskad comes from a new abstraction: the Timestream.
Timestreams provide a declarative API like dataframes over the complete temporal context.
Easily combine multiple streams and reason about the complete sequence of events.
Use time-travel to compute training examples from historic data and understand how results change over time.

## What are "Timestreams"?

Kaskada is built on the concept of a _Timestream_.
Each Timestream is ordered by _time_ and partitioned by _entity_.
This makes it easy to focus on events happening over time and how aggregations change.

<!---
A [Timestream](timestreams) describes how a value changes over time.
In the same way that SQL queries transform tables and graph queries transform nodes and edges, Kaskada queries transform Timestreams.

In comparison to a timeseries which often contains simple values (e.g., numeric observations) defined at fixed, periodic times (i.e., every minute), a Timestream contains any kind of data (records or collections as well as primitives) and may be defined at arbitrary times corresponding to when the events occur.

% The input for this needs to be hidden, not removed. It seems that plotly won't
% render the right height otherwise (possibly because it's not attached to the DOM?).
% We could see if this worked better using a different library such as `bokeh` or if
% there were better options to pass to plotly to avoid the problem.
-->

```{python}
# | code-fold: true
# | warning: false
import asyncio
import kaskada as kd
kd.init_session()
data = "\n".join(
    [
        "time,key,m",
        "1996-12-19T16:39:57,A,5",
        "1996-12-19T17:42:57,B,8",
        "1996-12-20T16:39:59,A,17",
        "1996-12-23T12:18:57,B,6",
        "1996-12-23T16:40:01,A,12",
    ]
)
multi_entity = await kd.sources.CsvString.create(data, time_column="time", key_column="key")

kd.plot.render(
    kd.plot.Plot(multi_entity.col("m"), name="m")
)
```

## Continuity

It is useful to consider two kinds of timestreams -- _discrete_ and _continuous_.
Like the example we already saw, a discrete timestream consists of values at specific points in time.
On the other hand, a continuous timestream represents a value that continues until it changes.
While a discrete timestream contains values at specific points in time, a continuous timestream changes at specific points in time.

For example, the result of aggregating a timestream produces a continuous stream that changes on each non-`null` input.

```{python}
# | echo: false
# | warning: false
kd.plot.render(
    kd.plot.Plot(multi_entity.col("m").sum(), name="sum(m)")
)
```
