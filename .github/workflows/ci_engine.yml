name: Engine (wren + sparrow) CI

on:
  pull_request:
    branches: [main]
  push:
    branches: [main]
  merge_group:
    branches: [main]
  workflow_call:
  workflow_dispatch:

# In cases of concurrent workflows running (consecutive pushes to PR)
# leave the latest workflow and cancel the other (older) workflows
# See https://docs.github.com/en/actions/using-jobs/using-concurrency
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  actions: write
  # Used by clippy action to report lint errors.
  checks: write
  contents: read
  # For pushing Docker images to ghcr.io.
  packages: write

env:
  IMAGE: ghcr.io/${{ github.repository }}/engine-integration-tests

jobs:
  build_wren:
    name: Build wren (golang)
    uses: ./.github/workflows/reusable_ci_wren.yml

  build_sparrow:
    name: Build sparrow (rust)
    uses: ./.github/workflows/reusable_ci_rust.yml

  run_integration_tests: 
    name: Run integration tests
    needs: [build_wren, build_sparrow]
    runs-on: ubuntu-latest
    if: ${{ needs.build_wren.outputs.should_skip != true || needs.build_sparrow.outputs.should_skip != true }}
    steps:
      - name: Checkout sources
        uses: actions/checkout@v3

      - name: Get wren binary
        uses: actions/download-artifact@v3
        with:
          name: wren-binary
          path: ci-bin/wren/

      - name: Get Sparrow binary
        uses: actions/download-artifact@v3
        with:
          name: engine-debug
          path: ci-bin/engine/

      - name: Install Buf
        uses: bufbuild/buf-setup-action@v1.12.0
        with:
          version: "1.10.0"
          buf_user: ${{ secrets.BUF_USER }}
          buf_api_token: ${{ secrets.BUF_API_TOKEN }}
          github_token: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate Protos
        run: buf generate
        working-directory: proto

      - name: Install GoLang
        uses: actions/setup-go@v3
        with:
          go-version: "1.19"
          cache: true
          cache-dependency-path: wren/go.sum

      - name: Generate ent
        run: go generate ./ent
        working-directory: wren

      - name: Copy NOTICE
        run: cp NOTICE ./wren/

      - name: Create data dir with correct permissions 
        run: |
          mkdir -p tests/integration/data/tmp
          chmod -R a+rw tests/integration/ 
          echo "::group::Data Dir"
          ls -laR tests/integration/data
          echo "::endgroup::"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Docker compose up for integration tests 
        run: |
          DOCKER_BUILDKIT=1 docker compose -f ./tests/integration/docker-compose-ci-integration.yml up --build --detach
          
      - name: Check docker containers healthcheck
        run: |    
          timeout 240s sh -c 'until docker ps | grep pulsar | grep -q healthy; do echo "Waiting for container to be healthy..."; sleep 10; done'

      # Workaround: The db file `kaskada.db` gets generated from within the kaskada container and is owned by the container's `root`
      # Before we run any tests we make sure that all files under tests/integration/data (mapepd to /data in the container) is 
      # set to the user and group *of the user on GitHub runner* and make it -rw- for all. 
      # A better fix would probably be to match the user and group of the container to the user and group of the runner.  
      - name: Run integration tests
        run: | 
          echo "::group::Data Dir"
          sudo chown -R $USER:$(id -g -n $USER) tests/integration/data
          chmod -R a+rw tests/integration/
          ls -laR tests/integration/data
          echo "::endgroup::"

          make test/int/run-api

      - name: Docker compose down for integration tests 
        run: |  
          docker compose -f ./tests/integration/docker-compose-ci-integration.yml down